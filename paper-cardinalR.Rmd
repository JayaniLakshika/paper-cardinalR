---
title: "cardinalR: Generating interesting high-dimensional data structures"
abstract: >
  A high-dimensional dataset is where each observation is described by many features, or dimensions. Such a dataset might contain various types of structures that have complex geometric properties, such as nonlinear manifolds, clusters, or sparse distributions. We can generate data containing a variety of structures using mathematical functions and statistical distributions. Sampling from a multivariate normal distribution will generate data in an elliptical shape. Using a trigonometric function we can generate a spiral. A torus function can create a donut shape. High-dimensional data structures are useful for testing, validating, and improving algorithms used in dimensionality reduction, clustering, machine learning, and visualization. Their controlled complexity allows researchers to understand challenges posed in data analysis and helps to develop robust analytical methods across diverse scientific fields like bioinformatics, machine learning, and forensic science. Functions to generate a large variety of structures in high dimensions are organized into the R package `cardinalR`, along with some already generated examples.
draft: true
author:  
  - name: Jayani P. Gamage
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: https://jayanilakshika.netlify.app/
    orcid: 0000-0002-6265-6481
    email:  \email{jayani.piyadigamage@monash.edu}
  - name: Dianne Cook
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: http://www.dicook.org/
    email: dicook@monash.edu
    orcid: 0000-0002-3813-7155
  - name: Paul Harrison
    affiliation: Monash University
    address: MGBP, BDInstitute, VIC 3800 Australia
    email: paul.harrison@monash.edu
    orcid: 0000-0002-3980-268X
  - name: Michael Lydeamore
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    email: michael.lydeamore@monash.edu
    orcid: 0000-0001-6515-827X
  - name: Thiyanga S. Talagala
    affiliation: University of Sri Jayewardenepura
    address: Department of Statistics, Gangodawila, Nugegoda 10100 Sri Lanka
    url: https://thiyanga.netlify.app/
    email: ttalagala@sjp.ac.lk
    orcid: 0000-0002-0656-9789
type: package
creative_commons: CC BY
date: "`r Sys.Date()`"
preamble: >
  \usepackage{amsmath}
  \usepackage{array}
output: 
 rjtools::rjournal_web_article:
    css: "style.css"
    keep_md: true
bibliography: paper-cardinalR.bib
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
options(repos = "https://cloud.r-project.org") ## set up CRAN mirror
knitr::opts_chunk$set(
  echo = FALSE,
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE,
  out.width = "100%")

```

```{r set-seed}
set.seed(20240412)
```

```{r load-libraries}
library(cardinalR)
library(tidyverse)
library(kableExtra)
library(geozoo)
library(patchwork)
library(colorspace)
```

```{r}
#| label: plot-theme
theme_set(theme_linedraw() +
   theme(
     #aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "bottom", 
     legend.title = element_blank(), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm')
   )
)
```


```{r}
interior_annotation <- function(label, position = c(0.92, 0.92), cex = 1, col="grey70") {
  annotation_custom(grid::textGrob(label = label,
                                   x = unit(position[1], "npc"), y = unit(position[2], "npc"),
                                   gp = grid::gpar(cex = cex, col=col)))
}
```

# Introduction

Generating synthetic datasets with clearly defined geometric properties is essential for evaluating and benchmarking algorithms in various fields, such as machine learning, data mining, and computational biology. Researchers often need to generate data with specific dimensions, noise characteristics, and complex underlying structures to test the performance and robustness of their methods.

There are numerous packages available in R for generating synthetic data, each designed with unique characteristics and focus areas. For example, `geozoo` (@barret2016) offers a large collection of geometric objects, allowing users to create and analyze specific shapes, primarily in lower-dimensional spaces. Another useful package is `snedata` (@james2025), which provides tools for generating simplified datasets useful for evaluating dimensionality reduction techniques like tSNE, often focusing on understanding and evaluating low-dimensional embeddings of complex data structures. Additionally, `mlbench` (@friedrich2024) includes a collection of well-known benchmark datasets commonly associated with established classification or regression challenges. In the field of single-cell omics, `splatter` (@luke2017) is particularly simulate complex biological data, effectively capturing nuances such as batch effects and differential expression.

There is a valuable opportunity to improve the generation of high-dimensional data structures by integrating geometric principles with advanced noise control and customizable clustering. The `geozoo` package provides a strong foundation but could be enhanced to support high-dimensional extensions with controlled noise and user-defined parameters for clustering. Similarly, while `snedata` focuses on abstract datasets for dimensionality reduction, adding features for generating high-dimensional data from geometric layouts would enhance its usability. The `mlbench` package could also benefit from allowing users to create datasets with specific geometric structures and noise profiles. Additionally, although `splatter` specializes in biological data simulation, it could be expanded to offer a broader framework for generating diverse geometric structures across dimensions, enabling detailed control over noise and clustering. Addressing these areas could lead to more robust high-dimensional data generation tools.

To address this gap, this paper introduces the `cardinalR` R package. This package provides a collection of functions designed to generate customizable data structures in any number of dimensions, starting from basic geometric shapes. `cardinalR` offers important functionalities that extend beyond the capabilities of existing tools, allowing users to: (i) construct high-dimensional datasets based on geometric shapes, including the option to enhance dimensionality by adding controlled noise dimensions; (ii) introduce adjustable levels of background noise to these structures; and (iii) create complex clustered data arrangements by using fundamental geometric forms, while maintaining their positions, scales, orientations, and sample sizes in arbitrary dimensional spaces. By providing these integrated features, `cardinalR` aims to provide researchers to generate more explainable and challenging synthetic datasets focused to the specific needs of evaluating algorithms in high-dimensions. This bridges the gap between geometric foundations and the flexible generation of complex synthetic data.

The paper is organized as follows. In next section, introduces the implementation of `cardinalR` package on CRAN and GitHub, including demonstration of the package's key functions. We illustrate how a clustering data structure affect the dimension reductions in **Application** section. Finally, we give a brief conclusion of the paper and discuss potential opportunities for use of our data collection.

# Implementation

## Installation

The package can be installed from CRAN using 

```r
install.packages("cardinalR")
```

and the development version can be installed from GitHub 

```r
devtools::install_github("JayaniLakshika/cardinalR")
```

## Web site

More documentation of the package can be found at the web site <https://jayanilakshika.github.io/cardinalR/>.

## Data sets

The `cardinalR` package comes with several data sets that load with the package. These are described in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:datasets-tb-html)', '\\@ref(tab:datasets-tb-pdf)'))`.

```{r}
datasets_tb <- tibble(dt = c("mobiusgau", 
                             "mobiusgau_tsne1", 
                             "mobiusgau_tsne2",
                             "mobiusgau_tsne3",
                             "mobiusgau_umap1",
                             "mobiusgau_umap2",
                             "mobiusgau_umap3"), 
                      text = c("Simulated data with a Mobius and a Gaussian in 4-D space.",
                               "The tSNE embedding with perplexity $15$ for mobiusgau.", 
                               "The tSNE embedding with perplexity $30$ for mobiusgau.",
                               "The tSNE embedding with perplexity $5$ for mobiusgau.",
                               "The UMAP embedding with number of neighbors $15$ and minimum distance $0.1$ for mobiusgau.",
                               "The UMAP embedding with number of neighbors $30$ and minimum distance $0.08$ for mobiusgau.", 
                               "The UMAP embedding with number of neighbors $5$ and minimum distance $0.9$ for mobiusgau."))
```

```{r datasets-tb-html, eval=knitr::is_html_output()}
datasets_tb |> 
  kable(caption = "cardinalR data sets", col.names = c("data", "explanation")) 
```

```{r datasets-tb-pdf, eval=knitr::is_latex_output()}
datasets_tb |> 
  kable(caption = "cardinalR data sets", format="latex", col.names = c("data", "explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

## Functions

### Main function

Add main function argument list to a table...

```{r, echo=TRUE, eval=FALSE}
gen_multicluster(
  n = c(200, 300, 500), p = 4, k = 3,
  loc = matrix(c(
    0, 0, 0, 0,
    5, 9, 0, 0,
    3, 4, 10, 7
  ), nrow = 4, byrow = TRUE),
  dim_weights = dim4_weights,
  scale = c(3, 1, 2),
  shape = c("gaussian", "bluntedcorn", "unifcube"),
  rotation = rotations_4d,
  is_bkg = FALSE
)
```

### Branching

```{r}
branch_tb <- tibble(fun = c("gen_expbranches",
                             "gen_linearbranches",
                             "gen_curvybranches", 
                             "gen_orglinearbranches", 
                             "gen_orgcurvybranches"), 
                      exp = c("",
                               "", 
                               "",
                               "",
                               ""))
```

```{r branching-tb-html, eval=knitr::is_html_output()}
branch_tb |> 
  kable(caption = "cardinalR branching data generation functions", col.names = c("Function", "Explanation")) 
```

```{r branching-tb-pdf, eval=knitr::is_latex_output()}
branch_tb |> 
  kable(caption = "cardinalR branching data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```


### Cone

### Cube

```{r}
cube_tb <- tibble(fun = c("gen_gridcube",
                          "gen_unifcube",
                          "gen_cubehole"), 
                      exp = c("",
                              "", 
                              ""))
```

```{r cube-tb-html, eval=knitr::is_html_output()}
cube_tb |> 
  kable(caption = "cardinalR cube data generation functions", col.names = c("Function", "Explanation")) 
```

```{r cube-tb-pdf, eval=knitr::is_latex_output()}
cube_tb |> 
  kable(caption = "cardinalR cube data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

### Gaussian

### Linear

### Mobius

### Polynomial

```{r}
polynomial_tb <- tibble(fun = c("gen_quadratic",
                                "gen_cubic"), 
                        exp = c("",
                                ""))
```

```{r polynomial-tb-html, eval=knitr::is_html_output()}
polynomial_tb |> 
  kable(caption = "cardinalR polynomial data generation functions", col.names = c("Function", "Explanation")) 
```

```{r polynomial-tb-pdf, eval=knitr::is_latex_output()}
polynomial_tb |> 
  kable(caption = "cardinalR polynomial data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

### Pyramid

```{r}
pyramid_tb <- tibble(fun = c("gen_pyr",
                             "gen_pyrrect",
                             "gen_pyrtri",
                             "gen_pyrstar",
                             "gen_pyrholes"), 
                        exp = c("",
                                "",
                                "",
                                "",
                                ""))
```

```{r pyramid-tb-html, eval=knitr::is_html_output()}
pyramid_tb |> 
  kable(caption = "cardinalR pyramid data generation functions", col.names = c("Function", "Explanation")) 
```

```{r pyramid-tb-pdf, eval=knitr::is_latex_output()}
pyramid_tb |> 
  kable(caption = "cardinalR pyramid data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

### S-curve

```{r}
scurve_tb <- tibble(fun = c("gen_scurve",
                            "gen_scurvehole"), 
                        exp = c("",
                                ""))
```

```{r scurve-tb-html, eval=knitr::is_html_output()}
scurve_tb |> 
  kable(caption = "cardinalR S-curve data generation functions", col.names = c("Function", "Explanation")) 
```

```{r scurve-tb-pdf, eval=knitr::is_latex_output()}
scurve_tb |> 
  kable(caption = "cardinalR S-curve data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```


### Sphere

```{r}
sphere_tb <- tibble(fun = c("gen_circle",
                            "gen_curvycycle",
                            "gen_unifsphere",
                            "gen_gridedsphere",
                            "gen_clusteredspheres"), 
                        exp = c("",
                                "",
                                "",
                                "",
                                ""))
```

```{r sphere-tb-html, eval=knitr::is_html_output()}
sphere_tb |> 
  kable(caption = "cardinalR sphere data generation functions", col.names = c("Function", "Explanation")) 
```

```{r sphere-tb-pdf, eval=knitr::is_latex_output()}
sphere_tb |> 
  kable(caption = "cardinalR sphere data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

### Swiss Roll  

To generalize the Swiss roll structure to arbitrary dimensions, we introduce a function `generate_swiss_roll(n, p)`, which constructs a high-dimensional version of the classic 3D Swiss roll while preserving its core characteristics.  

The function generates `n` points in a `p`-dimensional space, where the first two dimensions (`X_1, X_2`) define the primary Swiss roll shape using a parametric equation:  

$$
X_1 = t \cos(t), \quad X_2 = t \sin(t), \quad \text{where } t \sim U(0, 3\pi)
$$

The third dimension (`X_3`) introduces variation perpendicular to the roll, sampled uniformly from \([-1,1]\). Additional dimensions (`X_4` to `X_p`) extend the data structure by applying a **sinusoidal transformation** of the parameter `t`, ensuring continuity in higher-dimensional spaces:  

$$
X_i = \frac{\sin(i t)}{i}, \quad \text{for } i \geq 4.
$$

This transformation ensures a gradual decay in variance across dimensions, mimicking real-world high-dimensional structures where later dimensions often capture subtler variations. 

### Trigonometric

```{r}
trigonometric_tb <- tibble(fun = c("gen_crescent",
                            "gen_curvycylinder",
                            "gen_sphericalspiral",
                            "gen_helicalspiral",
                            "gen_conicspiral",
                            "gen_nonlinear"), 
                        exp = c("",
                                "",
                                "",
                                "",
                                "",
                                ""))
```

```{r trigonometric-tb-html, eval=knitr::is_html_output()}
trigonometric_tb |> 
  kable(caption = "cardinalR trigonometric data generation functions", col.names = c("Function", "Explanation")) 
```

```{r trigonometric-tb-pdf, eval=knitr::is_latex_output()}
trigonometric_tb |> 
  kable(caption = "cardinalR trigonometric data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

### Odd shapes

Add table of odd shapes..

### Additional functions

```{r}
add_fun_tb <- tibble(fun = c("gen_noisedims",
                            "gen_bkgnoise",
                            "randomize_rows",
                            "gen_nproduct",
                            "gen_nsum",
                            "gen_wavydims1",
                            "gen_wavydims2",
                            "gen_wavydims3",
                            "gen_rotation",
                            "normalize_data"), 
                        exp = c("",
                                "",
                                "",
                                "",
                                "",
                                "",
                                "",
                                "",
                                "",
                                ""))
```

```{r add-tb-html, eval=knitr::is_html_output()}
add_fun_tb |> 
  kable(caption = "cardinalR additional functions", col.names = c("Function", "Explanation")) 
```

```{r add-tb-pdf, eval=knitr::is_latex_output()}
add_fun_tb |> 
  kable(caption = "cardinalR additional functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

# Application

<!-- 1) Generate a data structure with different shapes (two non-linear, one gaussian, one linear, one cone in 5-D simplex) and fit different NLDR (Then, demonstrate how this data can be used to assess the ability of different dimensionality reduction techniques (e.g., PCA, t-SNE, UMAP) to preserve the underlying structure in a lower-dimensional embedding.) -->

<!-- 2) Add noise dimensions to the same data by linking two or three clusters, then discuss how single and complete linkage affect for the solutions (refer Di's book <https://dicook.github.io/mulgar_book/8-hierarchical.html>) -->

## Assessing the performance of dimension reduction on different geometric structures in high-dimensions

We illustrate the use of the package by generating five clusters of different shapes, positioned with equal inter-cluster distances in $4\text{-}D$. Using this synthetic dataset, we will evaluate the performance of six popular dimension reduction techniques: Principal Component Analysis (PCA) [@jolliffe2011], t-distributed stochastic neighbor embedding (tSNE) [@laurens2008], uniform manifold approximation and projection (UMAP) [@leland2018], potential of heat-diffusion for affinity-based trajectory embedding (PHATE) algorithm [@moon2019], large-scale dimensionality reduction Using triplets (TriMAP) [@amid2019], and pairwise controlled manifold approximation (PaCMAP) [@yingfan2021]. 

```{r gen-five-clust-data}

positions <- geozoo::simplex(p=4)$points
positions <- positions * 0.8

## To generate data
five_clusts <- gen_multicluster(n = c(2250, 1500, 750, 1250, 1750), p = 4, k = 5,
                       loc = positions,
                       scale = c(0.4, 0.35, 0.3, 1, 0.3),
                       shape = c("helicalspiral", "hemisphere", "unifcube", "bluntedcone", "gaussian"),
                       rotation = NULL,
                       is_bkg = FALSE)
```

```{r, eval=FALSE}
langevitour::langevitour(five_clusts[, -5])
```

```{r five-clusts-projections}

```

```{r layouts}
clusters <- as.vector(five_clusts[, 5])

tsne_data <- read_rds("data/five_clusts/five_clusts_tsne_perplexity_30.rds")

nldr1 <- tsne_data |>
  ggplot(aes(x = tSNE1,
             y = tSNE2))+
  geom_point(alpha=0.1, size=1, colour='#000000') +
  interior_annotation("a", c(0.08, 0.93)) +
  theme(aspect.ratio = 1) 

umap_data <- read_rds("data/five_clusts/five_clusts_umap_n-neigbors_15_min-dist_0.1.rds")

nldr2 <- umap_data |>
  ggplot(aes(x = UMAP1,
             y = UMAP2))+
  geom_point(alpha=0.1, size=1, colour='#000000') +
  interior_annotation("b", c(0.08, 0.93)) +
  theme(aspect.ratio = 1) 

phate_data <- read_rds("data/five_clusts/five_clusts_phate_knn_5.rds")

nldr3 <- phate_data |>
  ggplot(aes(x = PHATE1,
             y = PHATE2))+
  geom_point(alpha=0.1, size=1, colour='#000000') +
  interior_annotation("c", c(0.08, 0.93)) +
  theme(aspect.ratio = 1) 

trimap_data <- read_rds("data/five_clusts/five_clusts_trimap_n-inliers_12_n-outliers_4_n-random_3.rds")

nldr4 <- trimap_data |>
  ggplot(aes(x = TriMAP1,
             y = TriMAP2))+
  geom_point(alpha=0.1, size=1, colour='#000000') +
  interior_annotation("d", c(0.08, 0.93)) +
  theme(aspect.ratio = 1) 

pacmap_data <- read_rds("data/five_clusts/five_clusts_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds")

nldr5 <- pacmap_data |>
  ggplot(aes(x = PaCMAP1,
             y = PaCMAP2))+
  geom_point(alpha=0.1, size=1, colour='#000000') +
  interior_annotation("e", c(0.08, 0.93)) +
  theme(aspect.ratio = 1) 

pca_data <- read_rds("data/five_clusts/five_clusts_pca.rds")

nldr6 <- pca_data |>
  ggplot(aes(x = pca1,
             y = pca2))+
  geom_point(alpha=0.1, size=1, colour='#000000') +
  interior_annotation("f", c(0.08, 0.93)) +
  theme(aspect.ratio = 1) 
```

```{r}
nldr1 + nldr2 + nldr3 +
  nldr4 + nldr5 + nldr6 +
  plot_layout(ncol = 3)
```

# Discussion

<!-- The application of our high-dimensional data generation package to evaluate the interplay between dimensionality reduction, nuisance variables, and hierarchical clustering yielded several key insights. The ability to generate synthetic datasets with well-defined underlying structures, coupled with the controlled introduction of nuisance variables, provided a valuable platform for assessing the robustness of downstream unsupervised learning techniques. -->

<!-- Our findings demonstrated that the choice of dimensionality reduction method significantly impacted the ability of hierarchical clustering to recover the true underlying clusters. Methods that effectively preserved the global structure of the data, as defined by our generation process, generally led to more accurate and interpretable hierarchical clustering results. However, the presence of nuisance variables often confounded the low-dimensional embeddings, making it more challenging for hierarchical clustering to separate truly distinct groups. This highlights a critical consideration in real-world data analysis, where unmeasured or latent factors can obscure the signal of interest. -->

<!-- The hierarchical clustering analysis itself, and the choice of linkage criteria, also played a crucial role. Different linkage methods revealed varying degrees of sensitivity to the distorted representations caused by the nuisance variables. For instance, methods that prioritize compact clusters might have been more susceptible to being misled by variance introduced by nuisance factors, while others focusing on the distance between clusters might have shown more resilience. The dendrograms generated by hierarchical clustering provided a visual means to explore the relationships between samples and the potential influence of nuisance, although determining the optimal number of clusters remained a challenge in the presence of these confounding factors. -->

<!-- This application underscores the utility of our data generation package as a powerful tool for controlled experimentation in unsupervised learning. By providing the ground truth cluster assignments and the ability to systematically manipulate data characteristics like dimensionality, geometric structure, and the presence of nuisance variables, researchers can gain a deeper understanding of the strengths and limitations of various DR and clustering algorithms. This controlled environment allows for a more objective evaluation than often possible with real-world datasets where the underlying structure is unknown. -->

<!-- One limitation of this particular application was the specific type and magnitude of the nuisance variables introduced. Future work could explore a wider range of nuisance types (e.g., batch effects, technical noise with specific distributions) and their varying degrees of influence on different DR and clustering methodologies. Furthermore, investigating strategies for mitigating the impact of nuisance variables, either during the DR step or within the clustering process itself, would be a valuable extension. -->

<!-- In conclusion, this example demonstrates the critical role of synthetic data generation in dissecting the complex interactions within unsupervised learning pipelines. Our package provides a flexible and controlled means to create such data, enabling researchers to systematically evaluate the performance and robustness of dimensionality reduction and clustering algorithms under well-defined conditions, including the presence of confounding factors. This capability contributes to a more rigorous and informed approach to high-dimensional data analysis. -->

# Code

The code is available at <https://github.com/JayaniLakshika/cardinalR>, and source material for this paper is available at <https://github.com/JayaniLakshika/paper-cardinalR>.

# Acknowledgements

This article is created using \CRANpkg{knitr} [@yihui2015] and \CRANpkg{rmarkdown} [@yihui2018] in R with the `rjtools::rjournal_article` template. 
