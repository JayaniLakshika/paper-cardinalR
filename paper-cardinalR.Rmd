---
title: "cardinalR: Generating interesting high-dimensional data structures"
abstract: >
  A high-dimensional dataset is where each observation is described by many features, or dimensions. Such a dataset might contain various types of structures that have complex geometric properties, such as nonlinear manifolds, clusters, or sparse distributions. We can generate data containing a variety of structures using mathematical functions and statistical distributions. Sampling from a multivariate normal distribution will generate data in an elliptical shape. Using a trigonometric function we can generate a spiral. A torus function can create a donut shape. High-dimensional data structures are useful for testing, validating, and improving algorithms used in dimensionality reduction, clustering, machine learning, and visualization. Their controlled complexity allows researchers to understand challenges posed in data analysis and helps to develop robust analytical methods across diverse scientific fields like bioinformatics, machine learning, and forensic science. Functions to generate a large variety of structures in high dimensions are organized into the R package `cardinalR`, along with some already generated examples.
draft: true
author:  
  - name: Jayani P. Gamage
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: https://jayanilakshika.netlify.app/
    orcid: 0000-0002-6265-6481
    email:  \email{jayani.piyadigamage@monash.edu}
  - name: Dianne Cook
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: http://www.dicook.org/
    email: dicook@monash.edu
    orcid: 0000-0002-3813-7155
  - name: Paul Harrison
    affiliation: Monash University
    address: MGBP, BDInstitute, VIC 3800 Australia
    email: paul.harrison@monash.edu
    orcid: 0000-0002-3980-268X
  - name: Michael Lydeamore
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    email: michael.lydeamore@monash.edu
    orcid: 0000-0001-6515-827X
  - name: Thiyanga S. Talagala
    affiliation: University of Sri Jayewardenepura
    address: Department of Statistics, Gangodawila, Nugegoda 10100 Sri Lanka
    url: https://thiyanga.netlify.app/
    email: ttalagala@sjp.ac.lk
    orcid: 0000-0002-0656-9789
type: package
creative_commons: CC BY
date: "`r Sys.Date()`"
preamble: >
  \usepackage{amsmath}
  \usepackage{array}
  \usepackage{float}
  \newcommand\pD{$p\text{-}D$}
  \newcommand\gD{$2\text{-}D$}
output: 
 rjtools::rjournal_article:
    keep_md: true
bibliography: paper-cardinalR.bib
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
options(repos = "https://cloud.r-project.org") ## set up CRAN mirror
knitr::opts_chunk$set(
  echo = FALSE,
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE,
  out.width = "100%",
  fig.pos = "!")

```

```{r set-seed}
set.seed(20240412)
```

```{r install-libraries, include=FALSE, warning=FALSE, echo=FALSE}

options(repos = c(CRAN = "https://cran.rstudio.com")) # Setup mirror

packages_to_check <- c("remotes", "cardinalR", "tidyverse", "kableExtra", "geozoo", "patchwork", "colorspace")

for (pkg in packages_to_check) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message(paste("Installing package:", pkg))
    install.packages(pkg)
  } else {
    installed_version <- packageVersion(pkg)
    available_version <- tryCatch({
      utils::packageDescription(pkg)$Version
    }, error = function(e) NA) # Handle cases where package info isn't readily available

    if (!is.na(available_version) && installed_version < package_version(available_version)) {
      message(paste("A newer version of package", pkg, "is available. Updating..."))
      install.packages(pkg)
    } else {
      message(paste("Package", pkg, "is up-to-date (version", installed_version, ")."))
    }
  }
}

```

```{r load-libraries}
library(cardinalR)
library(tidyverse)
library(kableExtra)
library(geozoo)
library(patchwork)
library(colorspace)
library(crosstalk)
```

```{r}
#| label: plot-theme
theme_set(theme_linedraw() +
   theme(
     aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "bottom", 
     legend.title = element_blank(), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )
)
```

```{r}
#| label: import-scripts
source("scripts/additional_functions.R")
```

# Introduction

Generating synthetic datasets with clearly defined geometric properties is essential for evaluating and benchmarking algorithms in various fields, such as machine learning, data mining, and computational biology. Researchers often need to generate data with specific dimensions, noise characteristics, and complex underlying structures to test the performance and robustness of their methods.

There are numerous packages available in R for generating synthetic data, each designed with unique characteristics and focus areas.The `geozoo` package (@barret2016) offers a large collection of geometric objects, allowing users to create and analyze specific shapes, primarily in lower-dimensional spaces. Another useful package is `snedata` (@james2025), which provides tools for generating simplified datasets useful for evaluating dimensionality reduction techniques like tSNE, often focusing on understanding and evaluating low-dimensional embeddings of complex data structures. Additionally, `mlbench` (@friedrich2024) includes a collection of well-known benchmark datasets commonly associated with established classification or regression challenges. In the field of single-cell omics, `splatter` (@luke2017) is designed to simulate complex biological data, capturing field-specific nuances such as batch effects and differential expression. While these packages are valuable, their scope is often limited to specific applications or low-dimensional structures.

To address this gap, this paper introduces the `cardinalR` R package. This package provides a collection of functions designed to generate customizable data structures in any number of dimensions, starting from basic geometric shapes. `cardinalR` offers important functionalities that extend beyond the capabilities of existing tools, allowing users to: (i) construct high-dimensional datasets based on geometric shapes, including the option to enhance dimensionality by adding controlled noise dimensions; (ii) introduce adjustable levels of background noise to these structures; and (iii) combine high-dimensional datasets into a single multi-faceted, clustered dataset in a space of arbitrary dimension. By using clearly defined geometric shapes and controllable characteristics such as number of dimensions, sample size; `cardinalR` allows researchers to generate transparent and interpretable synthetic datasets for evaluating algorithm performance in high-dimensional settings. 

By providing these aspects, `cardinalR` provides researchers with a method to generate more explainable and challenging high-dimensional clustering synthetic datasets focused to the specific needs of evaluating algorithms.

The paper is organized as follows. In the next section, we introduce the implementation of the `cardinalR` package on GitHub, including a demonstration of the package's key functions. We illustrate how a clustering data structure affects the dimension reductions in the Application section. Finally, we give a brief conclusion of the paper and discuss potential opportunities for the use of our data collection.


# Implementation

## Installation

The development version can be installed from GitHub: 

```r
pak::pak("JayaniLakshika/cardinalR")
```

<!-- ## Web site -->

<!-- More documentation of the package can be found at the web site [https://jayanilakshika.github.io/cardinalR/](https://jayanilakshika.github.io/cardinalR/). -->

## Usage

### Main function

The main function of the package is `gen_multicluster()`, which generates datasets consisting of multiple clusters with user-specified characteristics. Users can control the number of clusters (`k`), the number of points in each cluster (`n`), and the dimensionality of the space (`p`) for all the clusters. Each cluster can take on a different geometric shape (e.g., Gaussian, cone, uniform cube), be scaled to adjust its spread, rotated in specified planes by given angles, and positioned at defined centroids (`loc`). The function ensures flexibility in cluster location and orientation, allowing users to simulate complex high-dimensional structures. An optional argument, `is_bkg`, adds background noise drawn from a multivariate normal distribution centered on the datasetâ€™s overall mean with standard deviations matching the observed spread.

The main arguments of the `gen_multicluster()` function are shown in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:main-tb-html)', '\\@ref(tab:main-tb-pdf)'))`.

```{r}
main_tb <- tibble(arg = c("n",
                          "p",
                          "k",
                          "loc",
                          "scale",
                          "shape",
                          "rotation",
                          "is_bkg"),
                  type = c("numeric (vector)",
                           "numeric",
                           "numeric",
                           "numeric (matrix)",
                           "numeric (vector)",
                           "character (vector)",
                           "numeric (list)",
                           "boolean"),
                        exp = c("Number of points in each cluster.",
                                "Number of dimensions.",
                                "Number of clusters.",
                                "Locations/centroids of clusters.",
                                "Scaling factors of clusters.",
                                "Shapes of clusters.",
                                "Plane and the corresponding angle along that plane for each cluster.",
                                "Background noise should exist or not."))
```

```{r main-tb-html, eval=knitr::is_html_output()}
main_tb |> 
  kable(caption = "The main arguments for `gen_multicluster()`.", col.names = c("Argument", "Type", "Explanation")) 
```

```{r main-tb-pdf, eval=knitr::is_latex_output()}
main_tb |> 
  kable(caption = "The main arguments for gen\\_multicluster().", format="latex", col.names = c("Argument", "Type", "Explanation"), booktabs = T, table.pos = "H")  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "4cm") |>
  column_spec(3, width = "8cm")
```

### Shape generators

The shape generators form the foundation of the package, providing a collection of functions to create synthetic data structures based on simple, well-defined geometric structures. These include fundamental shapes such as cones, pyramids, spheres, grids, and branching structures. If a shape is not inherently defined in more than three dimensions, additional noise dimensions can be added to embed the structure into higher-dimensional space. Users can specify how these noise dimensions are generated (e.g., Gaussian, uniform), offering control over the embedding process. All shape generators allow the user to define the number of points and dimensions, and most include additional arguments to customize specific characteristics of the structure. 

### Branching

A branching structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch)"} else { "Figure \\@ref(fig:branch-proj)"})`) captures trajectories that diverge or bifurcate from a common origin, similar to processes such as cell differentiation in biology (@trapnell2014). We introduce a set of data generation functions specifically designed to simulate high-dimensional branching structures with various geometries, numbers of points, and number of branches. Although these functions can generate multiple branches, they do not produce a formal *multicluster* dataset: the branches form a single connected structure, with multiple visually distinct arms rather than independent clusters. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:branching-tb-html)', '\\@ref(tab:branching-tb-pdf)'))` outlines these functions. The main arguments of the functions described in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:arg-branching-tb-html)', '\\@ref(tab:arg-branching-tb-pdf)'))`.

```{r}
branch_tb <- tibble(fun = c("gen_expbranches",
                             "gen_linearbranches",
                             "gen_curvybranches", 
                             "gen_orglinearbranches", 
                             "gen_orgcurvybranches"), 
                      exp = c("Generate a structure with exponential shaped branches.",
                               "Generate a structure with linear shaped branches.", 
                               "Generate a structure with curvy shaped branches.",
                               "Generate a structure with linear shaped branches originated in one point.",
                               "Generate a structure with curvy shaped branches originated in one point."))
```

```{r branching-tb-html, eval=knitr::is_html_output()}
branch_tb |> 
  kable(caption = "cardinalR branching data generation functions", col.names = c("Function", "Explanation")) 
```

```{r branching-tb-pdf, eval=knitr::is_latex_output()}
branch_tb |> 
  kable(caption = "cardinalR branching data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

```{r}
arg_branching_tb <- tibble(arg = c("n",
                          "p",
                          "k"), 
                        exp = c("A numeric value representing the number of points.",
                                "A numeric value representing the number of dimensions.",
                                "A numeric value representing the number of clusters."))
```

```{r arg-branching-tb-html, eval=knitr::is_html_output()}
arg_branching_tb |> 
  kable(caption = "The main arguments for branching shape generators.", col.names = c("Argument", "Explanation")) 
```

```{r arg-branching-tb-pdf, eval=knitr::is_latex_output()}
arg_branching_tb |> 
  kable(caption = "The main arguments for branching shape generators.", format="latex", col.names = c("Argument", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

#### `gen_expbranches()`

The `gen_expbranches(n, p, k)` function generates a dataset of $n$ points forming $k$ exponential branches in $2\text{-}D$, with optional noise dimensions to embed the structure in $p\text{-}D$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch) a"} else { "Figure \\@ref(fig:branch-proj) a"})`). These branches grow in opposite directions, producing a radiating curvilinear structure from a central region.

Each branch $i$ is constructed using $X_1 \sim U(-2, 2)$ and $X_2 = \exp(\pm s_iX_1) + \epsilon$, where: $\epsilon \sim U(0, 0.1)$ adds local jitter, $s_i \in [0.5, 2]$ is randomly sampled for each branch. The sign of the exponent alternates between branches: odd-numbered branches have a negative exponent (decaying pattern), and even-numbered branches have a positive exponent (growing pattern), producing mirror-symmetric curves with varying steepness. For $p > 2$, Gaussian noise $X_j \sim N(0, 0.1^2)$ is added to embed the $2\text{-}D$ branches into $p\text{-}D$, where $j = 3, \dots, p$.

```{r data-expbranches, echo=TRUE}
expbranches <- gen_expbranches(n = 1000, p = 4, k = 4)
```

```{r}
expbranches_lang <- langevitour::langevitour(expbranches, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r expbranches-proj1}
scaled_data <- scale_data_manual(expbranches)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.022))

expbranches_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.35, 0.7), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r expbranches-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.2,
                                              axis_scaled = 1.7, 
                                              axis_pos_x = -0.16, 
                                              axis_pos_y = -0.16, 
                                              threshold = 0.02))

expbranches_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.2, 0.2), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r expbranches-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.2,
                                              axis_scaled = 1.3, 
                                              axis_pos_x = -0.16, 
                                              axis_pos_y = -0.16, 
                                              threshold = 0.016))

expbranches_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.2, 0.2), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_linearbranches()`

The `gen_linearbranches(n, p, k)` function generates a dataset of $n$ points forming $k$ approximately linear branches in $p\text{-}D$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch) b"} else { "Figure \\@ref(fig:branch-proj) b"})`). The core structure lies in the first two dimensions and additional dimensions carry Gaussian noise.

The `gen_linearbranches(n, p, k)` function generates a dataset of $n$ points in $p\text{-}D$ forming $k$ linear branches. Each branch is a line segment with added jitter to simulate noise. Branches $1$ and $2$ are initialized with fixed slopes and intercepts: branch $1$ has slope $0.5$ and intercept $0$, with $X_1 \sim U(-2, 8)$ and $X_2 = 0.5 X_1 + \epsilon$, $\epsilon \sim U(0, 0.5)$; branch $2$ has slope $-0.5$ and intercept $0$, with $X_1 \sim U(-6, 2)$ and $X_2 = -0.5 X_1 + \epsilon$, $\epsilon \sim U(0, 0.5)$.

Branches $3$ to $k$ are added iteratively. Each new branch starts at a location outside predefined exclusion zones to avoid overlap with the first two branches. Specifically, $X_1$ starting points are sampled outside the intervals $[-8, -7]$, $[-2, 2]$, and $[7, 8]$, and $X_2$ starting points are sampled outside $[7, 8]$. For each new branch $i$, $X_1$ values are drawn over a short interval $[x_{\text{start}}, x_{\text{start}} + 1]$, and $X_2$ values are calculated as $X_2 = s_i (X_1 - x_{\text{start}}) + y_{\text{start}} + \epsilon$, where $s_i$ is a randomly chosen slope from a filtered sequence and $\epsilon \sim U(0, 0.2)$. For $p > 2$, Gaussian noise $X_j \sim N(0, 0.05^2)$ is added to embed the $2\text{-}D$ branches into $p\text{-}D$, for $j = 3, \dots, p$. 


```{r data-linearbranches, echo=TRUE}
linearbranches <- gen_linearbranches(n = 1000, p = 4, k = 4)
```

```{r}
linearbranches_lang <- langevitour::langevitour(linearbranches, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r linearbranches-proj1}
scaled_data <- scale_data_manual(linearbranches)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

linearbranches_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r linearbranches-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

linearbranches_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.7), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r linearbranches-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

linearbranches_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.65), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_curvybranches()`

The `gen_curvybranches(n, p, k)` function generates a dataset of $n$ points forming $k$ curvilinear branches embedded in $p\text{-}D$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch) c"} else { "Figure \\@ref(fig:branch-proj) c"})`). The underlying geometry lies in the first two dimensions, while the remaining $(p-2)$ dimensions contain Gaussian noise.

Branch $1$ is generated from $X_1 \sim U(0, 1)$, and $X_2 = 0.1X_1 + X_1^2 + \epsilon$, where $\epsilon \sim U(0, 0.05)$. This produces a gently upward-curving parabola in the right half-plane. Branch $2$ is generated from $X_{1} \sim U(-1, 0)$, and $X_2 = 0.1X_{1} - 2X_{1}^2 + \epsilon$, where $\epsilon \sim U(0, 0.05)$. This creates a steeper, leftward-facing curve in the left half-plane. Branches $3$ to $k$ are then added iteratively. Each new branch $i$ begins at a randomly chosen starting point $(x_{\text{start}}, y_{\text{start}})$ from the existing structure, where the horizontal coordinate $x_{\text{start}}$ is restricted to $[-0.15, 0.15]$ to ensure connectivity with the initial branches. From this starting point, the branch extends over a unit-length interval $X_1 \in [x_{\text{start}}, x_{\text{start}} + 1]$, with structure $X_2 = 0.1X_1 - s_i(X_1^2 - x_{\text{start}}) + y_{\text{start}}, ; s_i \in {-2, -1.5, -1, -0.5, 0, 0.5, 1.5}$. Here, each branch $i$ is assigned a single scale factor $s_i$, sampled independently from the set, which controls the curvature of that branch. The parameter $(x_{\text{start}}, y_{\text{start}})$ is the starting point chosen from the existing structure. This construction yields $k$ spatially connected, nonlinear branches with varying curvature. For $p > 2$, Gaussian noise $X_j \sim N(0, 0.05^2)$ is added to embed the $2\text{-}D$ branches into $p\text{-}D$, where $j = 3, \dots, p$.

```{r data-curvybranches, echo=TRUE}
curvybranches <- gen_curvybranches(n = 1000, p = 4, k = 4)
```

```{r}
curvybranches_lang <- langevitour::langevitour(curvybranches, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r curvybranches-proj1}
scaled_data <- scale_data_manual(curvybranches)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.65, 
                                              axis_pos_y = -0.65, 
                                              threshold = 0.022))

curvybranches_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.8, 0.7), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvybranches-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.3,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.02))

curvybranches_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.3, 0.3), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvybranches-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

curvybranches_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.4), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_orglinearbranches()`

The `gen_orglinearbranches(n, p, k)` function generates a dataset of $n$ points forming $k$ approximately linear branches embedded in $p\text{-}D$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch) d"} else { "Figure \\@ref(fig:branch-proj) d"})`). Each branch lies within a distinct $2\text{-}D$ subspace, while the remaining $p - 2$ dimensions contain Gaussian noise.

To construct each branch, a unique or repeated pair of dimensions is selected from the $\binom{p}{2}$ possible combinations of dimensions. If $k \leq \binom{p}{2}$, combinations are sampled without replacement. If $k > \binom{p}{2}$, additional pairs are sampled with replacement to reach $k$ total branches. Each selected pair $(i_1, i_2)$ defines the $2\text{-}D$ plane for branch $i$.

For branch $i$, $n_i$ points are generated, where $\sum_{i=1}^k n_i = n$. The structure follows: $X_{i_1} \sim U(0, 2)$, and $X_{i_2} = -s_iX_{i_1} + \epsilon, \quad \epsilon \sim U(0, 0.5)$, where $s_i$ is a scale factor controlling the slope. When $k \leq \binom{p}{2}$, $s_i = 1$. When sampling with replacement, $s_i$ is drawn from the set ${1, 1.5, 2, \dots, 8}$ in increments of $0.5$. For $p > 2$, the remaining dimensions contain independent Gaussian noise: $X_j \sim N(0, 0.1^2)$, for $j \notin \{i_1, i_2\}$.

```{r data-orglinearbranches, echo=TRUE}
orglinearbranches <- gen_orglinearbranches(n = 1000, p = 4, k = 4)
```

```{r}
orglinearbranches_lang <- langevitour::langevitour(orglinearbranches, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r orglinearbranches-proj1}
scaled_data <- scale_data_manual(orglinearbranches)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

orglinearbranches_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "d1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r orglinearbranches-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

orglinearbranches_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "d2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r orglinearbranches-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

orglinearbranches_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.62), 
  title = "d3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_orgcurvybranches()`

The `gen_orgcurvybranches(n, p, k)` function generates a dataset of $n$ points forming $k$ curvilinear branches embedded in a $p$-dimensional space (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch) e"} else { "Figure \\@ref(fig:branch-proj) e"})`). Each branch is constructed in a unique or repeated $2\text{-}D$ subspace of the $p$-dimensional space, with curvature induced by a second-degree polynomial structure. The remaining $p - 2$ dimensions contain Gaussian noise.

Let $\binom{p}{2}$ denote the number of unique $2\text{-}D$ subspace combinations. When $k \leq \binom{p}{2}$, $k$ distinct subspace pairs $(i_1, i_2)$ are sampled without replacement. Otherwise, combinations are selected with replacement to reach $k$ total branches. For each branch $i = 1, \dots, k$, a random scale factor $s_i$ is used to vary the curvature; If $k \leq \binom{p}{2}$: $s_i = 1$, or If $k > \binom{p}{2}$: $s_i \in \{1, 1.5, \dots, 8\}$.

Each branch contains $n_i$ points such that $\sum_{i=1}^k n_i = n$, where the vector $(n_1, \dots, n_k)$ is randomly drawn using the helper function `gen_nsum()` to partition $n$. Within its assigned subspace, branch $i$ is defined by: $X_{i_1} \sim U(0, 2)$, and $X_{i_2} = -s_iX_{i_1}^2 + \epsilon, \quad \epsilon \sim U(0, 0.5)$. This forms a smooth downward-opening parabola in the plane defined by $(X_{i_1}, X_{i_2})$, with the degree of curvature controlled by $s_i$. For $p > 2$, all remaining dimensions are independent Gaussian noise: $X_j \sim N(0, 0.1^2), \quad \text{for } j \notin \{i_1, i_2\}$.

```{r data-orgcurvybranches, echo=TRUE}
orgcurvybranches <- gen_orgcurvybranches(n = 1000, p = 4, k = 4)
```

```{r}
orgcurvybranches_lang <- langevitour::langevitour(orgcurvybranches, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r orgcurvybranches-proj1}
scaled_data <- scale_data_manual(orgcurvybranches)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.3, 
                                              axis_pos_y = -0.3, 
                                              threshold = 0.022))

orgcurvybranches_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.4, 0.5), 
  title = "e1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r orgcurvybranches-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

orgcurvybranches_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "e2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r orgcurvybranches-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

orgcurvybranches_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.62), 
  title = "e3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r branch, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `expbranches`, `linearbranches`, `curvybranches`, `orglinearbranches`, and `orgcurvybranches` data in $4\\text{-}D$."}

branchfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    expbranches_lang, linearbranches_lang, curvybranches_lang, orglinearbranches_lang, orgcurvybranches_lang
  ),
  device = "xs"
)

class(branchfig) <- c(class(branchfig), "htmlwidget")

branchfig
```

```{r branch-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `expbranches` (a1-a3), `linearbranches` (b1-b3), `curvybranches` (c1-c3), `orglinearbranches` (d1-d3), `orgcurvybranches` (e1-e3) data.", fig.width=15, fig.height=25}

expbranches_proj1 + expbranches_proj2 + expbranches_proj3 +
linearbranches_proj1 + linearbranches_proj2 + linearbranches_proj3 +
curvybranches_proj1 + curvybranches_proj2 + curvybranches_proj3 +
orglinearbranches_proj1 + orglinearbranches_proj2 + orglinearbranches_proj3 +
orgcurvybranches_proj1 + orgcurvybranches_proj2 + orgcurvybranches_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Cone

To simulate a cone-shaped structure in arbitrary dimensions (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:cone)"} else { "Figure \\@ref(fig:cone-proj)"})`), we define a function `gen_cone(n, p, h, ratio)`, which creates a high-dimensional cone with options for a sharp or blunted apex, allowing for a dense concentration of points near the tip.

This function generates $n$ points in $p\text{-}D$, where the last dimension, $X_p$, represents the height along the cone's axis, and the first $p-1$ dimensions define a shrinking hyperspherical cross-section toward the tip. Heights are sampled from a truncated exponential distribution, $X_p \sim \text{Exp}(\lambda = 2/h)$, capped at the cone height $h$, producing a higher density of points near the tip. At each height $X_p$, the radius of the cross-section decreases linearly from base to tip according to $r = r_{\text{min}} + (r_{\text{max}} - r_{\text{min}}) X_p / h$, where $r_{\text{min}} = \text{ratio}$ and $r_{\text{max}} = 1$.

For each point, a direction in the first $p-1$ dimensions is sampled uniformly on a $(p-1)$-dimensional hypersphere using generalized spherical coordinates. The radial coordinates are scaled by the height-dependent radius $r$, producing the conical taper. In three dimensions ($p = 3$), this results in a classical $3\text{-}D$ cone, while for $p > 3$, additional dimensions provide a smooth embedding into higher-dimensional space, preserving the conical structure.

```{r data-bluntedcone, echo=TRUE}
cone <- gen_cone(n = 1000, p = 4, h = 5, ratio = 0.5)
```

```{r}
cone_lang <- langevitour::langevitour(cone, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r cone-proj1}
scaled_data <- scale_data_manual(cone)

## First projection
projection <- cbind(
  c(0.22417,-0.02943,-0.02870,0.08418),
  c(-0.02715,0.18019,0.05053,0.15254))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.25,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.2, 
                                              axis_pos_y = -0.2, 
                                              threshold = 0.022))

cone_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.25, 0.25), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cone-proj2}

## Second projection
projection <- cbind(
    c(0.15591,0.17907,0.03198,0.04496),
    c(-0.15376,0.10435,0.15766,0.00547))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.1,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.08, 
                                              axis_pos_y = -0.08, 
                                              threshold = 0.01))

cone_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.1, 0.12), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cone-proj3}

## Third projection
projection <- cbind(
    c(-0.13548,0.13832,0.05991,-0.13544),
    c(0.08479,-0.10719,-0.01572,-0.20123))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.25,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.016))

cone_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.3, 0.2), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cone, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `cone` data in $4\\text{-}D$."}

conefig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    cone_lang
  ),
  device = "xs"
)

class(conefig) <- c(class(conefig), "htmlwidget")

conefig
```

```{r cone-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `cone` data."}
#| fig-width: 15
#| fig-height: 5

cone_proj1 + cone_proj2 + cone_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Cube

A cube structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:cube)"} else { "Figure \\@ref(fig:cube-proj)"})`) represents uniformly or systematically distributed points within a high-dimensional hypercube, providing a useful framework for assessing how well algorithms preserve uniformity, spacing, and boundary properties in high dimensions. We provide a set of functions to generate high-dimensional cube structures with flexible configurations, including regular grids, uniform random points, and cubes with missing regions or holes. These structures are valuable for testing the ability of algorithms to maintain uniform spacing or to detect gaps in the data. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:cube-tb-html)', '\\@ref(tab:cube-tb-pdf)'))` outlines these functions and their purposes. 

The first is the regular grid of points of $n$ points in $p$ dimensions. This is generated using `gen_gridcube(n, p)`. The number of grid points along each axis is determined by finding the nearest integer factors whose product is close to $n$. Each dimension is then normalized to lie in the interval $[0,1]$, so that the resulting structure forms a true $p\text{-}D$ hypercube. This produces a lattice of evenly spaced points along all axes, providing a uniform and interpretable high-dimensional grid.

```{r data-gridcube, echo=TRUE}
gridcube <- gen_gridcube(n = 1000, p = 4)
```

```{r}
gridcube_lang <- langevitour::langevitour(gridcube, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r gridcube-proj1}
scaled_data <- scale_data_manual(gridcube)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.7, 
                                              axis_pos_y = -0.7, 
                                              threshold = 0.022))

gridcube_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.83, 0.8), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r gridcube-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.8,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.85, 
                                              axis_pos_y = -0.85, 
                                              threshold = 0.05))

gridcube_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-1, 1), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r gridcube-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.7, 
                                              axis_pos_y = -0.7, 
                                              threshold = 0.016))

gridcube_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.8, 0.8), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

An extension to the regular grid of points is to consider the points being uniformly distributed along each axis, as opposed to evenly spaced. The function `gen_unifcube(n, p)` is identical to the regular grid of points, except instead of points being placed in integer grid coordinates, they are placed at a uniformly distributed point inside the $p\text{-}D$ cube (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:cube) b"} else { "Figure \\@ref(fig:cube-proj) b"})`).

```{r data-unifcube, echo=TRUE}
unifcube <- gen_unifcube(n = 1000, p = 4)
```

```{r}
unifcube_lang <- langevitour::langevitour(unifcube, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r unifcube-proj1}
scaled_data <- scale_data_manual(unifcube)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.75, 
                                              axis_pos_y = -0.75, 
                                              threshold = 0.022))

unifcube_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.9, 0.8), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r unifcube-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.75, 
                                              axis_pos_y = -0.75, 
                                              threshold = 0.04))

unifcube_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.9, 0.8), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r unifcube-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.65, 
                                              axis_pos_y = -0.65, 
                                              threshold = 0.016))

unifcube_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.8, 0.8), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Finally, we consider a cube that has a central spherical hole. This is generated using the `gen_cubehole(n, p, r_hole)` function. The cube is generated as per the uniformly distributed cube, but points inside sphere of radius (`r_hole`) are removed, resulting in a hollow cube structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:cube) c"} else { "Figure \\@ref(fig:cube-proj) c"})`).

```{r data-cubehole, echo=TRUE}
cubehole <- gen_cubehole(n = 3000, p = 4, r_hole = 0.5)
```

```{r}
cubehole_lang <- langevitour::langevitour(cubehole, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r cubehole-proj1}
scaled_data <- scale_data_manual(cubehole)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.75, 
                                              axis_pos_y = -0.75, 
                                              threshold = 0.022))

cubehole_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.9, 0.75), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cubehole-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.73, 
                                              axis_pos_y = -0.73, 
                                              threshold = 0.04))

cubehole_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.85, 0.7), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cubehole-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.75, 
                                              axis_pos_y = -0.75, 
                                              threshold = 0.016))

cubehole_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.9, 0.8), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r}
cube_tb <- tibble(fun = c("gen_gridcube",
                          "gen_unifcube",
                          "gen_cubehole"), 
                      exp = c("Generate a cube with specified grid points along each axes.",
                              "Generate a cube with uniform points.", 
                              "Generate a cube with a hole."))
```

```{r cube-tb-html, eval=knitr::is_html_output()}
cube_tb |> 
  kable(caption = "cardinalR cube data generation functions", col.names = c("Function", "Explanation")) 
```

```{r cube-tb-pdf, eval=knitr::is_latex_output()}
cube_tb |> 
  kable(caption = "cardinalR cube data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

```{r cube, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `gridcube`, `unifcube`, and `cubehole` data in $4\\text{-}D$."}

branchfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    gridcube_lang, unifcube_lang, cubehole_lang
  ),
  device = "xs"
)

class(branchfig) <- c(class(branchfig), "htmlwidget")

branchfig
```

```{r cube-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `gridcube` (a1-a3), `unifcube` (b1-b3), and `cubehole` (c1-c3) data.", fig.width=15, fig.height=15}

gridcube_proj1 + gridcube_proj2 + gridcube_proj3 +
unifcube_proj1 + unifcube_proj2 + unifcube_proj3 +
cubehole_proj1 + cubehole_proj2 + cubehole_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Gaussian

The `gen_gaussian(n, p, s)` function generates a multivariate Gaussian cloud in $p\text{-}D$, centered at the origin with user-defined covariance structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:gau)"} else { "Figure \\@ref(fig:gau-proj)"})`). Each point is independently drawn using the multivariate normal distribution with $X_i \sim N_p(\boldsymbol{0}, s)$, where $s$ is a user-defined $p \times p$ positive-definite matrix.

```{r data-gau, echo=TRUE}
gau <- gen_gaussian(n = 1000, p = 4, s = diag(4))
```

```{r}
gau_lang <- langevitour::langevitour(gau, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r gau-proj1}
scaled_data <- scale_data_manual(gau)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

gau_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r gau-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

gau_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r gau-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

gau_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r gau, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `gau` data in $4\\text{-}D$."}

gaufig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    gau_lang
  ),
  device = "xs"
)

class(gaufig) <- c(class(gaufig), "htmlwidget")

gaufig
```

```{r gau-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `gau` data."}
#| fig-width: 15
#| fig-height: 5

gau_proj1 + gau_proj2 + gau_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Linear

The `gen_longlinear(n, p)` function generates a high-dimensional dataset representing a long linear structure with noise. Each variable is formed as $X_i = \text{scale}_i \cdot (0,1,\dots,n{-}1 + \epsilon) + \text{shift}_i$, where $\text{scale}\_i \sim U(-10, 10)$ determines the orientation of the line in each dimension, $\text{shift}\_i \sim U(-300, 300)$ offsets the line to separate dimensions, and $\epsilon \sim N(0, (0.03n)^2)$ introduces Gaussian noise. 

```{r data-linear, echo=TRUE}
linear <- gen_longlinear(n = 1000, p = 4)
```

```{r}
linear_lang <- langevitour::langevitour(linear, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r linear-proj1}
scaled_data <- scale_data_manual(linear)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.022))

linear_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r linear-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.75,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.75, 
                                              axis_pos_y = -0.75, 
                                              threshold = 0.01))

linear_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.9, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r linear-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.9,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.02))

linear_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.7), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r linear, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `linear` data in $4\\text{-}D$."}

linearfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    linear_lang
  ),
  device = "xs"
)

class(linearfig) <- c(class(linearfig), "htmlwidget")

linearfig
```

```{r linear-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `linear` data."}
#| fig-width: 15
#| fig-height: 5

linear_proj1 + linear_proj2 + linear_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Mobius

The `gen_mobius(n, p)` function generates a dataset of $n$ points that form a Mobius strip embedded in the first three dimensions of a $p\text{-}D$ structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:mobius)"} else { "Figure \\@ref(fig:mobius-proj)"})`). This classical non-orientable surface loops back on itself with a half-twist.

The Mobius strip is generated using the `geozoo::mobius` function with `p = 3`, and `n` defined as above. Each point is sampled from a parameterization defined by an angle $\theta \sim U(0, 2\pi)$, which specifies the position along the circular loop, and a width $w \sim U(-0.4, 0.4)$, which offsets the point across the stripâ€™s band. The cartesian coordinates are $X_1 = \left(1 + (w/2) \cos(\theta/2)\right) \cos(\theta)$, $X_2 = \left(1 + (w/2) \cos(\theta/2)\right) \sin(\theta)$, and $X_3 = (w/2)\sin(\theta/2)$. This maps a $2\text{-}D$ band with a half-twist into $3\text{-}D$ space, forming a non-orientable one-sided surface. For $p > 3$, additional noise dimension are added to embed the $3\text{-}D$ Mobius into $p\text{-}D$.

```{r data-mobius, echo=TRUE}
mobius <- gen_mobius(n = 1000, p = 4)
```

```{r}
mobius_lang <- langevitour::langevitour(mobius, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r mobius-proj1}
scaled_data <- scale_data_manual(mobius)

## First projection
projection <- cbind(
    c(0.53506,0.00763,0.00097,-0.10901),
    c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

mobius_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r mobius-proj2}

## Second projection
projection <- cbind(
    c(-0.06614,0.15134,-0.44278,0.27367),
    c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

mobius_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r mobius-proj3}

## Third projection
projection <- cbind(
    c(0.10704,0.04822,-0.03416,0.53224),
    c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

mobius_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.62), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r mobius, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `mobius` data in $4\\text{-}D$."}

mobiusfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    mobius_lang
  ),
  device = "xs"
)

class(mobiusfig) <- c(class(mobiusfig), "htmlwidget")

mobiusfig
```

```{r mobius-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `mobius` data."}
#| fig-width: 15
#| fig-height: 5

mobius_proj1 + mobius_proj2 + mobius_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Polynomial

A polynomial structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:poly)"} else { "Figure \\@ref(fig:poly-proj)"})`) generates data points that follow non-linear curvilinear relationships, such as quadratic or cubic trends, in high-dimensional space. These patterns are useful for evaluating how well algorithms capture smooth, non-linear trajectories and curvature in the data. We provide functions for generating quadratic and cubic structures, enabling controlled experiments with different degrees of polynomial complexity. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:polynomial-tb-html)', '\\@ref(tab:polynomial-tb-pdf)'))` summarizes these functions and their purposes.

```{r}
polynomial_tb <- tibble(fun = c("gen_quadratic",
                                "gen_cubic"), 
                        exp = c("Generate a quadratic pattern.",
                                "Generate a cubic pattern."))
```

```{r polynomial-tb-html, eval=knitr::is_html_output()}
polynomial_tb |> 
  kable(caption = "cardinalR polynomial data generation functions", col.names = c("Function", "Explanation")) 
```

```{r polynomial-tb-pdf, eval=knitr::is_latex_output()}
polynomial_tb |> 
  kable(caption = "cardinalR polynomial data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

The first is the quadratic curve of $n$ points in $p$ dimensions. This is generated using `gen_quadratic(n, p, range)`. The independent variable is defined as $X_1 \sim U(\text{range}[1], \text{range}[2])$, and a raw polynomial basis of degree 2 is applied to form $X_2 = X_1 - X_1^2 + \varepsilon_2$, where $\varepsilon_2 \sim U(0, 0.5)$. This produces a smooth parabolic arc opening downward, with vertical jitter introduced by the noise term (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:poly) a"} else { "Figure \\@ref(fig:poly-proj) a"})`).

```{r data-quadratic, echo=TRUE}
quadratic <- gen_quadratic(n = 1000, p = 4)
```

```{r}
quadratic_lang <- langevitour::langevitour(quadratic, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r quadratic-proj1}
scaled_data <- scale_data_manual(quadratic)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.7, 
                                              axis_pos_y = -0.7, 
                                              threshold = 0.022))

quadratic_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.83, 0.65), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r quadratic-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

quadratic_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r quadratic-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

quadratic_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.62), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

The second is the cubic curve of $n$ points in $p$ dimensions. This is generated using `gen_cubic(n, p, range)`. The independent variable is defined as $X_1 \sim U(\text{range}[1], \text{range}[2])$, and a raw polynomial basis of degree $3$ is applied to construct $X_2 = X_1 + X_1^2 - X_1^3 + \varepsilon_2$, where $\varepsilon_2 \sim U(0, 0.5)$. This produces a more complex curvilinear structure than the quadratic case, with both upward and downward turning points (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:poly) b"} else { "Figure \\@ref(fig:poly-proj) b"})`).

```{r data-cubic, echo=TRUE}
cubic <- gen_cubic(n = 1000, p = 4)
```

```{r}
cubic_lang <- langevitour::langevitour(cubic, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r cubic-proj1}
scaled_data <- scale_data_manual(cubic)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

cubic_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cubic-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.7, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.05))

cubic_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cubic-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

cubic_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r poly, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `quadratic` and `cubic` data in $4\\text{-}D$."}

polyfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    quadratic_lang, cubic_lang
  ),
  device = "xs"
)

class(polyfig) <- c(class(polyfig), "htmlwidget")

polyfig
```

```{r poly-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `quadratic` (a1-a3) and `cubic` (b1-b3) data.", fig.width=15, fig.height=10}

quadratic_proj1 + quadratic_proj2 + quadratic_proj3 +
cubic_proj1 + cubic_proj2 + cubic_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

For all polynomial shapes, if $p > 2$, the structure is embedded into higher dimensions by appending additional noise dimensions.

#### Pyramid

A pyramid structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr)"} else { "Figure \\@ref(fig:pyr-proj)"})`) represents data arranged around a central apex and base, useful for exploring how algorithms handle pointed or layered geometries in high-dimensional space. The functions provided allow users to generate pyramids with rectangular, triangular, and star-shaped bases, and sharp or blunted apexes. Additionally, it is possible to create a pyramid with a fractal-like internal structure, enabling the study of non-convex and sparse regions. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:pyramid-tb-html)', '\\@ref(tab:pyramid-tb-pdf)'))` summarizes these functions.

Let $X_1, \dots, X_p$ denote the coordinates of the generated points. For the rectangular and triangular based pyramid generator functions, the final dimension, $X_p$, encodes the height of each point and is drawn from an exponential distribution capped at the maximum height $h$. That is, $$X_p = z \sim \min\left(\text{Exp}(\lambda = 2/h),\ h\right).$$ This distribution creates a natural skew toward smaller height values, resulting in a denser concentration of points near the pyramid's apex. For the star-shaped base pyramid, the final dimension is drawn from a uniform distribution. That is, $X_p = z \sim U(0, h)$.

The remaining dimensions are based on the specific pyramid shape. For the rectangular based pyramid, `gen_pyrrect(n, p, h, l_vec, rt)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) a"} else { "Figure \\@ref(fig:pyr-proj) a"})`), let $r_x(z)$ and $r_y(z)$ denote the half-widths of the rectangular cross-section at height $z$. That is, $r_x(z) = r_t + (l_x - r_t)z/h$, $r_y(z) = r_t + (l_y - r_t)z/h$. The first three coordinates are then defined as: $X_1 \sim U(-r_x(z),\ r_x(z))$, $X_2 \sim U(-r_y(z),\ r_y(z))$, and $X_3 \sim U(-r_x(z),\ r_x(z)).$ 

```{r data-pyrrect, echo=TRUE}
pyrrect <- gen_pyrrect(n = 1000, p = 4)
```

```{r}
pyrrect_lang <- langevitour::langevitour(pyrrect, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r pyrrect-proj1}
scaled_data <- scale_data_manual(pyrrect)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

pyrrect_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrrect-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.7, 
                                              axis_pos_x = -0.45, 
                                              axis_pos_y = -0.45, 
                                              threshold = 0.08))

pyrrect_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrrect-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

pyrrect_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.75), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For the triangular based pyramid, `gen_pyrtri(n, p, h, l, rt)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) b"} else { "Figure \\@ref(fig:pyr-proj) b"})`), let $r(z)$ denote the scaling factor (distance from the origin to triangle vertices) at height $z$. That is, $r(z) = r_t + (l-r_t)z/h$. A point in the triangle at height $z$ is generated using barycentric coordinates $(u, v)$ to ensure uniform sampling within the triangular cross-section: $u, v \sim U(0, 1), \quad \text{if } u + v > 1: u \leftarrow 1 - u,\ v \leftarrow 1 - v$. The first three coordinates (triangle plane) are then: $X_1 = r(z)(1 - u - v)$, $X_2 = r(z)u$, and $X_3 = r(z)v.$ 

```{r data-pyrtri, echo=TRUE}
pyrtri <- gen_pyrtri(n = 1000, p = 4)
```

```{r}
pyrtri_lang <- langevitour::langevitour(pyrtri, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r pyrtri-proj1}
scaled_data <- scale_data_manual(pyrtri)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.3,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.2, 
                                              axis_pos_y = -0.2, 
                                              threshold = 0.022))

pyrtri_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.25, 0.3), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrtri-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.3,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.03))

pyrtri_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.3, 0.4), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrtri-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

pyrtri_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For the star based pyramid, `gen_pyrstar(n, p, h, rb)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) c"} else { "Figure \\@ref(fig:pyr-proj) c"})`), let the radius at height $z$, $r(z)$, be such that the radius scales linearly from zero (tip) to the base radius $r_b$. That is, $r(z) = r_b\left(1 - z/h\right)$.

Each point is placed within a regular hexagon in the plane $(X_1, X_2)$, using a randomly chosen hexagon sector angle $\theta \in \{0, \pi/3, 2\pi/3, \pi, 4\pi/3, 5\pi/3\}$ and a uniformly random radial scaling factor: $\theta \sim \text{Uniform sample from 6 hexagon angles}$,
$r_{\text{point}} \sim \sqrt{U(0, 1)}$. Then, the first two coordinates are: $X_1 = r(z)r_{\text{point}}\cos(\theta)$, and $X_2 = r(z)r_{\text{point}}\sin(\theta)$.

```{r data-pyrstar, echo=TRUE}
pyrstar <- gen_pyrstar(n = 1000, p = 4)
```

```{r}
pyrstar_lang <- langevitour::langevitour(pyrstar, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r pyrstar-proj1}
scaled_data <- scale_data_manual(pyrstar)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

pyrstar_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrstar-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

pyrstar_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.4), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrstar-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

pyrstar_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For all the above pyramid shapes, if $p > 3$, the remaining $p - 3$ dimensions (i.e., $X_4$ to $X_{p-1}$) are additional noise.

Finally, for the Sierpinski-like pyramid, `gen_pyrfrac(n, p)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) d"} else { "Figure \\@ref(fig:pyr-proj) d"})`), let $X_1, X_2, \dots, X_p$ denote the coordinates of the generated points. The generation process begins with an initial point $T_0 \in [0, 1]^p$ drawn from a uniform distribution: $T_0 \sim U(0, 1)^p$. Let $C_1, C_2, \dots, C_{p+1}$ denote the corner vertices of a $p\text{-}D$ simplex. At each iteration $i = 1, \dots, n$, a new point is computed by taking the midpoint between the previous point $T_{i-1}$ and a randomly selected vertex $C_k$: $T_i = 1/2(T_{i-1} + C_k), \quad C_k \in \{C_1, \dots, C_{p+1}\}$. This recursive midpoint rule generates self-similar patterns with systematic voids (holes) between clusters of points. The points remain bounded inside the convex hull of the simplex. The final output is a $n \times p$ matrix where each row represents a point: $X = \{T_1, T_2, \dots, T_n\}, \quad X \in \mathbb{R}^{n \times p}$.

```{r data-pyrholes, echo=TRUE}
pyrholes <- gen_pyrfrac(n = 1000, p = 4)
```

```{r}
pyrholes_lang <- langevitour::langevitour(pyrholes, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r pyrholes-proj1}
scaled_data <- scale_data_manual(pyrholes)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

pyrholes_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "d1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrholes-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

pyrholes_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.75), 
  title = "d2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrholes-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

pyrholes_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "d3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r}
pyramid_tb <- tibble(fun = c("gen_pyrrect",
                             "gen_pyrtri",
                             "gen_pyrstar",
                             "gen_pyrfrac"), 
                        exp = c("Rectangular-base pyramid, with a sharp or blunted apex.",
          "Triangular-base pyramid, with a sharp or blunted apex.",
          "Star-shaped base pyramid, with a sharp or blunted apex.",
          "Pyramid containing triangular pyramid-shaped holes."))
```

```{r pyramid-tb-html, eval=knitr::is_html_output()}
pyramid_tb |> 
  kable(caption = "cardinalR pyramid data generation functions", col.names = c("Function", "Explanation")) 
```

```{r pyramid-tb-pdf, eval=knitr::is_latex_output()}
pyramid_tb |> 
  kable(caption = "cardinalR pyramid data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

```{r pyr, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `pyrrect`, `pyrtri`, `pyrstar`, and `pyrholes` data in $4\\text{-}D$."}

pyrfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    pyrrect_lang, pyrtri_lang, pyrstar_lang, pyrholes_lang
  ),
  device = "xs"
)

class(pyrfig) <- c(class(pyrfig), "htmlwidget")

pyrfig
```

```{r pyr-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `pyrrect` (a1-a3), `pyrtri` (b1-b3), `pyrstar` (c1-c3), and `pyrholes` (d1-d3) data.", fig.width=15, fig.height=20}

pyrrect_proj1 + pyrrect_proj2 + pyrrect_proj3 +
pyrtri_proj1 + pyrtri_proj2 + pyrtri_proj3 +
pyrstar_proj1 + pyrstar_proj2 + pyrstar_proj3 +
pyrholes_proj1 + pyrholes_proj2 + pyrholes_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### S-curve

An S-curve structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:scurve)"} else { "Figure \\@ref(fig:scurve-proj)"})`) simulates data that lies along a smooth, non-linear manifold. The functions generate both the standard S-curve shape and, a S-curve variant with structured hole that introduce missing or incomplete region. These variations are useful for evaluating how well algorithms capture non-linear geometry and handle incomplete manifolds in high-dimensional data. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:scurve-tb-html)', '\\@ref(tab:scurve-tb-pdf)'))` summarizes these functions.

```{r}
scurve_tb <- tibble(fun = c("gen_scurve",
                            "gen_scurvehole"), 
                        exp = c("Generate a S-curve.",
                                "Generate a S-curve with a hole."))
```

```{r scurve-tb-html, eval=knitr::is_html_output()}
scurve_tb |> 
  kable(caption = "cardinalR S-curve data generation functions", col.names = c("Function", "Explanation")) 
```

```{r scurve-tb-pdf, eval=knitr::is_latex_output()}
scurve_tb |> 
  kable(caption = "cardinalR S-curve data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

For the S-curve structure, `gen_scurve(n, p)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:scurve) a"} else { "Figure \\@ref(fig:scurve-proj) a"})`), the $3\text{-}D$ geometry is constructed by introducing a latent parameter, $\theta \sim U\left(-3\pi/2, 3\pi/2\right)$. This parameter controls the curvature of the manifold. The first three dimensions form the S-curve structure: $X_1 = \sin(\theta)$, $X_2 \sim U(0, 2)$, $X_3 = \text{sign}(\theta)(\cos(\theta) - 1)$. This configuration creates a horizontally curled shape in $(X_1, X_3)$, with additional band thickness in the $X_2$ direction. For $p > 3$, additional noise dimensions are appended to embed the structure in higher dimensions.

```{r data-scurve, echo=TRUE}
scurve <- gen_scurve(n = 1000, p = 4)
```

```{r}
scurve_lang <- langevitour::langevitour(scurve, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r scurve-proj1}
scaled_data <- scale_data_manual(scurve)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

scurve_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r scurve-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

scurve_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r scurve-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

scurve_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.62), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

To introduce missing or incomplete regions on the manifold, `gen_scurvehole(n, p)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:scurve) b"} else { "Figure \\@ref(fig:scurve-proj) b"})`) removes points in a localized region centered around the middle vertical section of the S-curve. Following a similar approach as `gen_cubehole()`, all observations within a fixed radius ($\sqrt{0.3}$) of the anchor point are excluded, creating a hole in the manifold while preserving the overall S-curve structure.

```{r data-scurvehole, echo=TRUE}
scurvehole <- gen_scurvehole(n = 1000, p = 4)
```

```{r}
scurvehole_lang <- langevitour::langevitour(scurvehole, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r scurvehole-proj1}
scaled_data <- scale_data_manual(scurvehole)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

scurvehole_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r scurvehole-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

scurvehole_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r scurvehole-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

scurvehole_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r scurve, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `scurve` and `scurvehole` data in $4\\text{-}D$."}

scurvefig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    scurve_lang, scurvehole_lang
  ),
  device = "xs"
)

class(scurvefig) <- c(class(scurvefig), "htmlwidget")

scurvefig
```

```{r scurve-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `scurve` (a1-a3) and `scurvehole` (b1-b3) data.", fig.width=15, fig.height=10}

scurve_proj1 + scurve_proj2 + scurve_proj3 + 
  scurvehole_proj1 + scurvehole_proj2 + scurvehole_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

### Sphere

Sphere-shaped structures (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere)"} else { "Figure \\@ref(fig:sphere-proj)"})`) are useful for evaluating how dimension reduction and clustering algorithms handle curved, symmetric manifolds in high-dimensional spaces. The package provides functions to generate a variety of spherical forms, including simple circles, uniform spheres, grid-based spheres, and complex arrangements like clustered spheres within a larger sphere. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:sphere-tb-html)', '\\@ref(tab:sphere-tb-pdf)'))` summarizes these functions.

```{r}
sphere_tb <- tibble(fun = c("gen_circle",
                            "gen_curvycycle",
                            "gen_unifsphere",
                            "gen_gridedsphere",
                            "gen_clusteredspheres",
                            "gen_hemisphere"), 
                        exp = c("Generate a circle.",
                                "Generate a curvy cell cycle.",
                                "Generate a uniform sphere.",
                                "Generate a grided sphere.",
                                "Generate multiple small spheres within a big sphere.",
                                "Generate a hemisphere."))
```

```{r sphere-tb-html, eval=knitr::is_html_output()}
sphere_tb |> 
  kable(caption = "cardinalR sphere data generation functions", col.names = c("Function", "Explanation")) 
```

```{r sphere-tb-pdf, eval=knitr::is_latex_output()}
sphere_tb |> 
  kable(caption = "cardinalR sphere data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

#### `gen_circle()`

The function `gen_circle(n, p)` generates a $p$-dimensional dataset of $n$ observations, where the first two dimensions form a unit circle, and the remaining dimensions are structured sinusoidal extensions of the angular parameter with progressively smaller scale (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) a"} else { "Figure \\@ref(fig:sphere-proj) a"})`).

A latent angle variable $\theta$ is uniformly sampled from the interval $[0, 2\pi]$. Coordinates in the first two dimensions represent a perfect circle on the plane: $X_1 = \cos(\theta), \quad X_2 = \sin(\theta)$. For dimensions $X_3$ through $X_p$, sinusoidal transformations of the angle $\theta$ are introduced. The first component is a scaling factor that decreases with the dimension index, defined as $\text{scale}_j = \sqrt{(0.5)^{j-2}}$ for $j = 3, \dots, p$. The second component is a phase shift that is proportional to the dimension index, specifically designed to decorrelate the curves, given by the formula $\phi_j = (j - 2)\pi/2p$. Each additional dimension is computed as: $X_j = \text{scale}_{j}\sin(\theta + \phi_j), \quad j = 3, \dots, p$.

```{r data-circle, echo=TRUE}
circle <- gen_circle(n = 1000, p = 4)
```

```{r}
circle_lang <- langevitour::langevitour(circle, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r circle-proj1}
scaled_data <- scale_data_manual(circle)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

circle_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.8), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r circle-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

circle_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.7), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r circle-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

circle_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.53), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_curvycycle()`

The `gen_curvycycle(n, p)` function generates a $p$-dimensional dataset of $n$ observations lying on a curved closed loop with controlled high-dimensional sinusoidal deviations (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) b"} else { "Figure \\@ref(fig:sphere-proj) b"})`). The structure forms a one-dimensional nonlinear cycle embedded in higher-dimensional space.

A latent angle variable $\theta$ is uniformly sampled from the interval $[0, 2\pi]$. The first three dimensions define a non-circular closed curve, referred to as a "curvy cycle". In this configuration, $X_1 = \cos(\theta)$ represents horizontal oscillation, while $X_2 = \sqrt{3}/3 + \sin(\theta)$ introduces a vertical offset to avoid centering the curve at the origin. Additionally, $X_3 = 1/3\cos(3\theta)$ introduces a third harmonic perturbation that intricately folds the curve three times along its path, creating a unique and complex shape that oscillates in both dimensions while incorporating the effects of the harmonic perturbation.

Together, these define a periodic, non-trivial, closed curve in $3\text{-}D$ with internal folds that produce a more complex geometry than a standard circle or ellipse. For dimensions $X_4$ through $X_p$, additional structured variability is introduced through decreasing amplitude scaling and phase-shifted sine waves. The scaling factor is defined as $\text{scale}_j = \sqrt{(0.5)^{j-3}}$ for $j$ ranging from $4$ to $p$, which means that the amplitude decreases as the dimension increases. Each dimension $X_j$ is then calculated using the formula $X_j = \text{scale}_j\sin(\theta + \phi_j)$, where the phase shift $\phi_j$ is given by $\phi_j = (j - 2)\pi/2p$. 

```{r data-curvycycle, echo=TRUE}
curvycycle <- gen_curvycycle(n = 1000, p = 4)
```

```{r}
curvycycle_lang <- langevitour::langevitour(curvycycle, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r curvycycle-proj1}
scaled_data <- scale_data_manual(curvycycle)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

curvycycle_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycycle-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.04))

curvycycle_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycycle-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

curvycycle_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_unifsphere()`

The `gen_unifsphere(n, p, r)` function generates a $p$-dimensional dataset of $n$ observations distributed approximately uniformly on the surface of a $3\text{-}D$ sphere of radius $r$, with additional Gaussian noise dimensions added when $p > 3$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) c"} else { "Figure \\@ref(fig:sphere-proj) c"})`).

Each observation lies on the surface of a sphere in $3\text{-}D$, constructed by generating $u \sim U(-1, 1)$ which represents the cosine of the polar angle $\phi$ and $\theta \sim U(0, 2\pi)$ which represents the azimuthal angle. The corresponding Cartesian coordinates are calculated as; $X_1 = r\sqrt{1 - u^2}\cos(\theta)$, $X_2 = r\sqrt{1 - u^2}\sin(\theta)$, $X_3 = ru$, which gives points uniformly distributed on the surface of a $3\text{-}D$ sphere (not within). For $p > 3$, additional noise dimensions $X_4$ to $X_p$ are generated.

```{r data-unifsphere, echo=TRUE}
unifsphere <- gen_unifsphere(n = 1000, p = 4)
```

```{r}
unifsphere_lang <- langevitour::langevitour(unifsphere, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r unifsphere-proj1}
scaled_data <- scale_data_manual(unifsphere)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

unifsphere_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r unifsphere-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

unifsphere_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.7), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r unifsphere-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

unifsphere_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.65), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_gridedsphere()`

The `gen_gridedsphere(n, p)` function generates a $p$-dimensional dataset of approximately $n$ points evenly distributed on the surface of a $(p!-!1)$-sphere (the unit sphere embedded in $\mathbb{R}^p$) (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) d"} else { "Figure \\@ref(fig:sphere-proj) d"})`).

The construction is based on a regular grid in spherical coordinates with $(p-1)$ angular variables. Specifically, for dimensions $j = 1, \dots, p-2$, the polar angles are defined on $[0, \pi]$. For the last angle ($j = p-1$), the azimuthal angle is defined on $[0, 2\pi]$.

The number of grid steps along each angular dimension is determined by factoring $n$ into $(p-1)$ approximately equal integers via `gen_nproduct(n, p - 1)`.

Each grid point is then mapped to Cartesian coordinates using the standard hyperspherical-to-Cartesian transformation:

$$
\begin{aligned}
X_1 &= \cos(\theta_1), \\
X_2 &= \sin(\theta_1)\cos(\theta_2), \\
X_3 &= \sin(\theta_1)\sin(\theta_2)\cos(\theta_3), \\
&\;\;\vdots \\
X_{p-1} &= \sin(\theta_1)\sin(\theta_2)\cdots \sin(\theta_{p-2})\cos(\theta_{p-1}), \\
X_p &= \sin(\theta_1)\sin(\theta_2)\cdots \sin(\theta_{p-2})\sin(\theta_{p-1}).
\end{aligned}
$$

Thus, the output is a deterministic grid of points lying exactly on the unit $(p-1)$-sphere, with no added noise dimensions.

```{r data-gridedsphere, echo=TRUE}
gridedsphere <- gen_gridedsphere(n = 1000, p = 4)
```

```{r}
gridedsphere_lang <- langevitour::langevitour(gridedsphere, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r gridedsphere-proj1}
scaled_data <- scale_data_manual(gridedsphere)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

gridedsphere_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "d1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r gridedsphere-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

gridedsphere_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.65), 
  title = "d2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r gridedsphere-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

gridedsphere_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.62), 
  title = "d3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_clusteredspheres()`

The `gen_clusteredspheres(n, k, p, r, loc)` function generates a synthetic dataset of $n_1 + kn_2$ observations in $p$-dimensional space, consisting of one large sphere of radius $r_1$ and $k$ smaller spheres of radius $r_2$, each centered at a different random location (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) e"} else { "Figure \\@ref(fig:sphere-proj) e"})`).

A large uniform sphere centered at the origin is created by sampling $n_1$ points uniformly on the surface of a $p\text{-}D$ sphere with a radius of $r_1$. The sampling is executed using the function `gen_unifsphere(n_1, p, r_1)`, which generates the desired points in the specified dimensional space.

In generation of $k$ smaller uniform spheres, each sphere contains $n_2$ points that are sampled uniformly on a sphere with a radius of $r_2$. These spheres are positioned at distinct random locations in $p$-space, with the center of each sphere being drawn from a normal distribution $N(0, \texttt{loc}^2 I_p)$.
    
Points on spheres are generated using the standard hyperspherical method, which involves sampling $u \sim U(-1, 1)$ to determine the cosine of the polar angle, and sampling $\theta \sim U(0, 2\pi)$ to determine the azimuthal angle (for $3\text{-}D$). Each observation is classified by cluster, with labels such as "big" for the large central sphere and "small_1" to "small_k" for the smaller spheres.

```{r data-clusteredspheres, echo=TRUE}
clusteredspheres <- gen_clusteredspheres(n = c(1000, 100), k = 3, p = 4, r = c(15, 3),
                                         loc = 10 / sqrt(3)) |>
  dplyr::select(-cluster)
```

```{r}
clusteredspheres_lang <- langevitour::langevitour(clusteredspheres, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r clusteredspheres-proj1}
scaled_data <- scale_data_manual(clusteredspheres)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

clusteredspheres_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "e1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r clusteredspheres-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

clusteredspheres_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "e2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r clusteredspheres-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

clusteredspheres_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.62), 
  title = "e3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

#### `gen_hemisphere()`

The `gen_hemisphere(n, p)` function generates a $p$-dimensional dataset of $n$ observations distributed approximately uniformly on a $4\text{-}D$ hemisphere, optionally extended with Gaussian noise in additional dimensions when $p > 4$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) f"} else { "Figure \\@ref(fig:sphere-proj) f"})`).

Each observation is situated on a restricted $4\text{-}D$ spherical surface, defined by spherical coordinates. The azimuthal angle $\theta_1 \sim U(0, \pi)$ in the $(x_1, x_2)$ plane, while the elevation angle $\theta_2 \sim U(0, \pi)$ in the $(x_2, x_3)$ plane. Additionally, $\theta_3 \sim U(0, \pi/2)$ in the $(x_3, x_4)$ plane, ensuring that the points remain restricted to a hemisphere. The coordinates are transformed into $4\text{-}D$ Cartesian space: $X_1 = \sin(\theta_1)\cos(\theta_2)$, $X_2 = \sin(\theta_1)\sin(\theta_2)$, $X_3 = \cos(\theta_1)\cos(\theta_3)$, $X_4 = \cos(\theta_1)\sin(\theta_3)$. This produces points on one side of a $4\text{-}D$ unit sphere, effectively generating a $4\text{-}D$ hemisphere. For $p > 4$, additional noise dimensions are added to embed the structure in higher dimensions.

```{r data-hemisphere, echo=TRUE}
hemisphere <- gen_hemisphere(n = 1000, p = 4)
```

```{r}
hemisphere_lang <- langevitour::langevitour(hemisphere, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r hemisphere-proj1}
scaled_data <- scale_data_manual(hemisphere)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

hemisphere_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "f1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r hemisphere-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

hemisphere_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "f2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r hemisphere-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

hemisphere_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.62), 
  title = "f3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r sphere, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `circle`, `curvycycle`, `unifsphere`, `gridedsphere`, `clusteredspheres`, and `hemisphere` data in $4\\text{-}D$."}

spherefig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    circle_lang, curvycycle_lang, unifsphere_lang, gridedsphere_lang, clusteredspheres_lang, hemisphere_lang
  ),
  device = "xs"
)

class(spherefig) <- c(class(spherefig), "htmlwidget")

spherefig
```

```{r sphere-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `circle` (a1-a3), `curvycycle` (b1-b3), `unifsphere` (c1-c3), `gridedsphere` (d1-d3), `clusteredspheres` (e1-e3), and `hemisphere` (f1-f3) data.", fig.width=15, fig.height=35, out.width="80%", fig.align='center'}

circle_proj1 + circle_proj2 + circle_proj3 +
curvycycle_proj1 + curvycycle_proj2 + curvycycle_proj3 +
unifsphere_proj1 + unifsphere_proj2 + unifsphere_proj3 +
gridedsphere_proj1 + gridedsphere_proj2 + gridedsphere_proj3 +
clusteredspheres_proj1 + clusteredspheres_proj2 + clusteredspheres_proj3 +
hemisphere_proj1 + hemisphere_proj2 + hemisphere_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Swiss Roll  

To further generalize the Swiss roll structure and introduce realistic noise, we define a function `gen_swissroll(n, p, w)`, where $n$ is the number of points, $p$ is the total number of dimensions, and $w$ is the vertical range in the third dimension (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:swissroll)"} else { "Figure \\@ref(fig:swissroll-proj)"})`). The first three dimensions form the classic $3\text{-}D$ Swiss roll shape. The $X_1 = t \cos(t)$, $X_2 = t \sin(t)$, $X_3 \sim U(w_1, w_2), \text{where } t \sim U(0, 3\pi)$. For $p > 3$, the remaining $p - 3$ dimensions are filled with noise to simulate high-dimensional complexity. 

```{r data-swissroll, echo=TRUE}
swissroll <- gen_swissroll(n = 1000, p = 4, w = c(-1, 1))
```

```{r}
swissroll_lang <- langevitour::langevitour(swissroll, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r swissroll-proj1}
scaled_data <- scale_data_manual(swissroll)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

swissroll_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r swissroll-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

swissroll_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.65), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r swissroll-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

swissroll_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r swissroll, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `swissroll` data in $4\\text{-}D$."}

swissrollfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    swissroll_lang
  ),
  device = "xs"
)

class(swissrollfig) <- c(class(swissrollfig), "htmlwidget")

swissrollfig
```

```{r swissroll-proj, eval=knitr::is_latex_output(), fig.pos="H", fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `swissroll` data."}
#| fig-width: 15
#| fig-height: 5

swissroll_proj1 + swissroll_proj2 + swissroll_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Trigonometric

Trigonometric-based structures provide flexible ways to simulate complex curved patterns and spirals that often arise in real-world high-dimensional data, such as in biological trajectories, or physical systems (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric)"} else { "Figure \\@ref(fig:triginometric-proj)"})`). The first few coordinates define the main geometric structure (e.g., crescent, cylinder, spiral, or helix), while for higher-dimensional embeddings, additional noise dimensions are appended: for the crescent shape this occurs when $p > 2$ (adding $X_3$ through $X_p$), and for all other trigonometric shapes when $p > 4$ (adding $X_5$ through $X_p$). These structures are particularly valuable for testing how well dimension reduction and clustering algorithms preserve intricate geometric and topological features. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:trigonometric-tb-html)', '\\@ref(tab:trigonometric-tb-pdf)'))` summarizes these functions.

```{r}
trigonometric_tb <- tibble(fun = c("gen_crescent",
                            "gen_curvycylinder",
                            "gen_sphericalspiral",
                            "gen_helicalspiral",
                            "gen_conicspiral",
                            "gen_nonlinear"), 
                        exp = c("Generate a crescent pattern.",
                                "Generate a curvy cylinder.",
                                "Generate a spherical spiral.",
                                "Generate a helical spiral.",
                                "Generate a conic spiral.",
                                "Generate a nonlinear hyperbola."))
```

```{r trigonometric-tb-html, eval=knitr::is_html_output()}
trigonometric_tb |> 
  kable(caption = "cardinalR trigonometric data generation functions", col.names = c("Function", "Explanation")) 
```

```{r trigonometric-tb-pdf, eval=knitr::is_latex_output()}
trigonometric_tb |> 
  kable(caption = "cardinalR trigonometric data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

First, the `gen_crescent(n, p)` function generates a $p$-dimensional dataset of $n$ observations based on a $2\text{-}D$ crescent-shaped manifold with optional structured high-dimensional noise (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) a"} else { "Figure \\@ref(fig:triginometric-proj) a"})`). Let $\theta \in [\pi/6, 2\pi]$ be a sequence of $n$ evenly spaced angles. The corresponding $2\text{-}D$ coordinates are defined by: $X_1 = \cos(\theta)$, $X_2 = \sin(\theta)$.

```{r data-crescent, echo=TRUE}
crescent <- gen_crescent(n = 1000, p = 4)
```

```{r}
crescent_lang <- langevitour::langevitour(crescent, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r crescent-proj1}
scaled_data <- scale_data_manual(crescent)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.3,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.15, 
                                              axis_pos_y = -0.15, 
                                              threshold = 0.022))

crescent_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.2, 0.3), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r crescent-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.3,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.2, 
                                              axis_pos_y = -0.2, 
                                              threshold = 0.02))

crescent_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.25, 0.2), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r crescent-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.75,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.45, 
                                              axis_pos_y = -0.45, 
                                              threshold = 0.03))

crescent_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.7), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Second, the `gen_curvycylinder(n, p, h)` function generates a $p$-dimensional dataset of $n$ observations structured as a $3\text{-}D$ cylindrical manifold with an added nonlinear curvy dimension, and optional noise dimensions when $p > 4$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) b"} else { "Figure \\@ref(fig:triginometric-proj) b"})`). The core structure consists of a circular base and height values, extended by a nonlinear fourth dimension. Let $\theta \sim U(0, 3\pi)$ represent a random angle on a circular base and $z \sim U(0, h)$ represent the height along the cylinder. The coordinates are defined as: $X_1 = \cos(\theta)$ (Circular base, x-axis), $X_2 = \sin(\theta)$ (Circular base, y-axis), $X_3 = z$ (Linear height), and $X_4 = \sin(z)$ (Nonlinear curvy variation along height).  

```{r data-curvycylinder, echo=TRUE}
curvycylinder <- gen_curvycylinder(n = 1000, p = 4, h = 10)
```

```{r}
curvycylinder_lang <- langevitour::langevitour(curvycylinder, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r curvycylinder-proj1}
scaled_data <- scale_data_manual(curvycylinder)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

curvycylinder_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycylinder-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

curvycylinder_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycylinder-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

curvycylinder_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.5), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For a spiraling path on a spherical surface in the first four dimensions, `gen_sphericalspiral(n, p, spins)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) c"} else { "Figure \\@ref(fig:triginometric-proj) c"})`), let $\theta \in [0, 2\pi \times \text{spins}]$ be the azimuthal angle (longitude), controls the number of spiral turns and the $\phi \in [0, \pi]$be the polar angle (latitude), controls the vertical sweep from the north to the south pole. Cartesian coordinates from spherical conversion: $X_1 = \sin(\phi)\cos(\theta)$, $X_2 = \sin(\phi)\sin(\theta)$, $X_3 = \cos(\phi) + \varepsilon$, where $\varepsilon \sim U(-0.5, 0.5)$ introduces vertical jitter, and $X_4 = \theta / \max(\theta)$: a normalized progression along the spiral path. This generates a spherical spiral curve embedded in $4\text{-}D$ space, combining both circular and vertical movement, with gentle curvature and non-linear progression.  

```{r data-sphericalspiral, echo=TRUE}
sphericalspiral <- gen_sphericalspiral(n = 1000, p = 4, spins = 1)
```

```{r}
sphericalspiral_lang <- langevitour::langevitour(sphericalspiral, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r sphericalspiral-proj1}
scaled_data <- scale_data_manual(sphericalspiral)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

sphericalspiral_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r sphericalspiral-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

sphericalspiral_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r sphericalspiral-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

sphericalspiral_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.5), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For a helical spiral in four dimensions, `gen_helicalspiral(n, p)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) d"} else { "Figure \\@ref(fig:triginometric-proj) d"})`), let $\theta \in [0, 5\pi/4]$ be a sequence of angles controlling rotation around a circle. Cartesian coordinates; $X_1 = \cos(\theta)$: circular trajectory along the x-axis, $X_2 = \sin(\theta)$: circular trajectory along the y-axis, $X_3 = 0.05\theta + \varepsilon_3$, with $\varepsilon_3 \sim U(-0.5, 0.5)$: linear progression (height) with vertical jitter, simulating a helix, and $X_4 = 0.1\sin(\theta)$: oscillates with $\theta$, representing a periodic "wobble" along the fourth dimension. 

```{r data-helicalspiral, echo=TRUE}
helicalspiral <- gen_helicalspiral(n = 1000, p = 4)
```

```{r}
helicalspiral_lang <- langevitour::langevitour(helicalspiral, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r helicalspiral-proj1}
scaled_data <- scale_data_manual(helicalspiral)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

helicalspiral_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "d1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r helicalspiral-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.7, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.05))

helicalspiral_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.5), 
  title = "d2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r helicalspiral-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

helicalspiral_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.67), 
  title = "d3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Similarly, the `gen_conicspiral(n, p, spins)` function generates a dataset of $n$ points forming a conical spiral in the first four dimensions of $p\text{-}D$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) e"} else { "Figure \\@ref(fig:triginometric-proj) e"})`). The geometry combines radial expansion, vertical elevation, and spiral deformation, simulating a structure that fans out like a $3\text{-}D$ conic helix. The shape is defined by parameter $\theta \in [0, 2\pi\text{spins}]$, controlling the angular progression of the spiral. The Archimedean spiral in the horizontal plane is represented by; $X_1 = \theta\cos(\theta)$ for radial expansion in x, and $X_2 = \theta\sin(\theta)$ for radial expansion in y. The growth pattern resembles a cone, with the height increasing according to $X_3 = 2\theta / \max(\theta) + \varepsilon_3$, with $\varepsilon_3 \sim U(-0.1, 0.6).$ Spiral modulation in the fourth dimension is represented by $X_4 = \theta\sin(2\theta) + \varepsilon_4$, with $\varepsilon_4 \sim U(-0.1, 0.6)$ which simulates a twisting helical component in a non-radial dimension. 

```{r data-conicspiral, echo=TRUE}
conicspiral <- gen_conicspiral(n = 1000, p = 4, spins = 1)
```

```{r}
conicspiral_lang <- langevitour::langevitour(conicspiral, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r conicspiral-proj1}
scaled_data <- scale_data_manual(conicspiral)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

conicspiral_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "e1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r conicspiral-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.65, 
                                              axis_pos_y = -0.65, 
                                              threshold = 0.01))

conicspiral_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.8, 0.5), 
  title = "e2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r conicspiral-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.45, 
                                              axis_pos_y = -0.45, 
                                              threshold = 0.016))

conicspiral_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.62), 
  title = "e3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Finally, the `gen_nonlinear(n, p, hc, non_fac)` function simulates a non-linear $2\text{-}D$ surface embedded in higher dimensions, constructed using inverse and trigonometric transformations applied to independent variables (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) f"} else { "Figure \\@ref(fig:triginometric-proj) f"})`). The $X_{1} \sim U(0.1, 2)$: base variable (avoids zero to prevent division errors), $X_{3} \sim U(0.1, 0.8)$: independent auxiliary variable, $X_{2} = hc/X_{1} + \text{nonfac}\sin(X_{1})$: non-linear combination of hyperbolic and sinusoidal transformations, creating sharp curvature and oscillation, and $X_{4} = \cos(\pi X_{1}) + \varepsilon$, with $\varepsilon \sim U(-0.1, 0.1)$: additional nonlinear variation based on cosine, simulating more subtle periodic structure. These transformations together result in a non-linear surface warped in multiple ways: sharp vertical shifts due to inverse terms, smooth waves from sine and cosine, and additional jitter. 

```{r data-nonlinear, echo=TRUE}
nonlinear <- gen_nonlinear(n = 1000, p = 4, hc = 1, non_fac = 0.5)
```

```{r}
nonlinear_lang <- langevitour::langevitour(nonlinear, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r nonlinear-proj1}
scaled_data <- scale_data_manual(nonlinear)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.3, 
                                              axis_pos_y = -0.3, 
                                              threshold = 0.022))

nonlinear_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.45, 0.73), 
  title = "f1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r nonlinear-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.45,
                                              axis_scaled = 1.3, 
                                              axis_pos_x = -0.2, 
                                              axis_pos_y = -0.2, 
                                              threshold = 0.01))

nonlinear_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.3, 0.46), 
  title = "f2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r nonlinear-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.45,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.016))

nonlinear_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.35, 0.4), 
  title = "f3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r triginometric, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of tthe `crescent`, `curvycylinder`, `sphericalspiral`, `helicalspiral`, `conicspiral`, and `nonlinear` data in $4\\text{-}D$."}

triginometricfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    crescent_lang, curvycylinder_lang, sphericalspiral_lang, helicalspiral_lang, conicspiral_lang, nonlinear_lang
  ),
  device = "xs"
)

class(triginometricfig) <- c(class(triginometricfig), "htmlwidget")

triginometricfig
```

```{r triginometric-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `crescent` (a1-a3), `curvycylinder` (b1-b3), `sphericalspiral` (c1-c3), `helicalspiral` (d1-d3), `conicspiral` (e1-e3), and `nonlinear` (f1-f3) data.", fig.width=15, fig.height=35, out.width="80%", fig.align='center'}

crescent_proj1 + crescent_proj2 + crescent_proj3 +
curvycylinder_proj1 + curvycylinder_proj2 + curvycylinder_proj3 +
sphericalspiral_proj1 + sphericalspiral_proj2 + sphericalspiral_proj3 +
helicalspiral_proj1 + helicalspiral_proj2 + helicalspiral_proj3 +
conicspiral_proj1 + conicspiral_proj2 + conicspiral_proj3 +
nonlinear_proj1 + nonlinear_proj2 + nonlinear_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

#### Trefoil knots

<!--https://laustep.github.io/stlahblog/posts/TorusKnot4D.html-->

The Trefoil is a closed, nontrivial one-dimensional manifold embedded in $3\text{-}D$ or $4\text{-}D$ space (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:trefoil)"} else { "Figure \\@ref(fig:trefoil-proj)"})`). The trefoil features topological complexity in the form of self-overlaps, making it a valuable test case for evaluating the ability of non-linear dimension reduction methods to preserve global structure, loops, and embeddings in high-dimensional data. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:trefoil-tb-html)', '\\@ref(tab:trefoil-tb-pdf)'))` summarizes these functions.

```{r}
trefoil_tb <- tibble(fun = c("gen_trefoil4d",
                            "gen_trefoil3d"), 
                        exp = c("Generate a trefoil in $4\\text{-}D$.",
                                "Generate a trefoil in $3\\text{-}D$."))
```

```{r trefoil-tb-html, eval=knitr::is_html_output()}
trefoil_tb |> 
  kable(caption = "cardinalR trefoil data generation functions", col.names = c("Function", "Explanation")) 
```

```{r trefoil-tb-pdf, eval=knitr::is_latex_output()}

trefoil_tb |> 
  kable(caption = "cardinalR trefoil data generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

For the $4\text{-}D$ trefoil knot, the function `gen_trefoil4d(n, p, steps)` generates the structure on the $3$-sphere ($S^3 \subset \mathbb{R}^4$) using two angular parameters, $\theta$ and $\phi$. A band of thickness around the knot path is controlled by the `steps` argument, while the number of $\theta$ and $\phi$ values is determined by the `steps` and `n` arguments, respectively (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:trefoil) a"} else { "Figure \\@ref(fig:trefoil-proj) a"})`). The coordinates are defined as $X_1 = \cos(\theta) \cos(\phi)$, $X_2 = \cos(\theta) \sin(\phi)$, $X_3 = \sin(\theta) \cos(1.5 \phi)$, and $X_4 = \sin(\theta) \sin(1.5 \phi)$, where $\theta$ and $\phi$ trace the knotâ€™s path. For $p > 4$, the quadratic structure is embedded into higher dimensions by appending additional noise dimensions.

```{r data-trefoil4d, echo=TRUE}
trefoil4d <- gen_trefoil4d(n = 500, p = 4, steps = 5)
```

```{r}
trefoil4d_lang <- langevitour::langevitour(trefoil4d, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r trefoil4d-proj1}
scaled_data <- scale_data_manual(trefoil4d)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

trefoil4d_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil4d-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

trefoil4d_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.65), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil4d-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

trefoil4d_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For the $3\text{-}D$ stereographic projection, `gen_trefoil3d(n, p, steps)` maps each point $(X_1, X_2, X_3, X_4) \in \mathbb{R}^4$ to $(X_1', X_2', X_3') \in \mathbb{R}^3$ using $X_1' = X_1 / (1 - X_4)$, $X_2' = X_2 / (1 - X_4)$, and $X_3' = X_3 / (1 - X_4)$, excluding points where $X_4 = 1$ to avoid division by zero (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:trefoil) b"} else { "Figure \\@ref(fig:trefoil-proj) b"})`). As with the $4\text{-}D$ case, optional noise dimensions can be added to embed the knot into higher-dimensional spaces.

```{r data-trefoil3d, echo=TRUE}
trefoil3d <- gen_trefoil3d(n = 500, p = 4, steps = 5)
```

```{r}
trefoil3d_lang <- langevitour::langevitour(trefoil3d, levelColors = "black", enableControls = FALSE, width = "500px", height = "400px")
```

```{r trefoil3d-proj1}
scaled_data <- scale_data_manual(trefoil4d)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

trefoil3d_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil3d-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

trefoil3d_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.65), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil3d-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

trefoil3d_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil, eval=knitr::is_html_output(), fig.cap="`langevitour` output  of the `trefoil4d` and `trefoil3d` data in $4\\text{-}D$."}

trefoilfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;",
    trefoil4d_lang, trefoil3d_lang
  ),
  device = "xs"
)

class(trefoilfig) <- c(class(trefoilfig), "htmlwidget")

trefoilfig
```

```{r trefoil-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the `trefoil4d` (a1-a3) and `trefoil3d` (b1-b3) data.", fig.width=15, fig.height=10}

trefoil4d_proj1 + trefoil4d_proj2 + trefoil4d_proj3 + 
  trefoil3d_proj1 + trefoil3d_proj2 + trefoil3d_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

### Generate noise dimensions

generate noise dimensions with a normal distribution and various wavy patterns, 

### Multiple cluster examples

By using the shape generators mentioned above, we can create various examples of multiple clusters. The package includes some of these examples, which are described in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:odd-shape-tb-html)', '\\@ref(tab:odd-shape-tb-pdf)'))`.

```{r}
odd_shapes_tb <- tibble(fun = c("make_mobiusgau",
                                "make_multigau",
                                "make_curvygau",
                                "make_klink_circles",
                                "make_chain_circles",
                                "make_klink_curvycycle",
                                "make_chain_curvycycle",
                                "make_gaucircles",
                                "make_gaucurvycycle",
                                "make_onegrid",
                                "make_twogrid_overlap",
                                "make_twogrid_shift",
                                "make_shape_para",
                                "make_three_clust_"), 
                        exp = c(
    "Generates a MÃ¶bius-like cluster combined with a Gaussian cluster.",
    "Generates multiple Gaussian clusters in high-dimensional space.",
    "Generates a curvilinear cluster with a Gaussian cluster.",
    "Generates K-link circular clusters (non-linear circular patterns).",
    "Generates chain-like circular clusters connected sequentially.",
    "Generates K-link curvy cycle clusters (curvilinear loop structures).",
    "Generates chain-like curvy cycle clusters connected sequentially.",
    "Generates circular clusters with a Gaussian cluster in the middle.",
    "Generates curvy circular clusters with a Gaussian cluster in the middle.",
    "Generates a single grid in two dimensions.",
    "Generates two overlapping grids.",
    "Generates two grids shifted relative to each other.",
    "Generates parallel shaped clusters.",
    "Generates three clusters with different shapes. (eg:- 01, 02, ..., 20)"))
```

```{r odd-shape-tb-html, eval=knitr::is_html_output()}
odd_shapes_tb |> 
  kable(caption = "cardinalR multiple clusters generation functions", col.names = c("Function", "Explanation")) 
```

```{r odd-shape-tb-pdf, eval=knitr::is_latex_output()}
odd_shapes_tb |> 
  kable(caption = "cardinalR multiple clusters generation functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

### Additional functions

The package includes various supplementary tools in addition to the shape generating functions mentioned earlier. These tools allow users to create background noise, randomize the rows of the data, relocate clusters, generate a vector whose product and sum are approximately equal to a target value, rotate structures, and normalize the data. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:add-tb-html)', '\\@ref(tab:add-tb-pdf)'))` details these functions.

```{r}
add_fun_tb <- tibble(fun = c("gen_noisedims",
                            "gen_bkgnoise",
                            "randomize_rows",
                            "relocate_clusters",
                            "gen_nproduct",
                            "gen_nsum",
                            "gen_wavydims1",
                            "gen_wavydims2",
                            "gen_wavydims3",
                            "gen_rotation",
                            "normalize_data"), 
                        exp = c("Generates additional noise dimensions.",
                                "Adds background noise.",
                                "Randomizes the rows.",
                                "Relocates the clusters.",
                                "Generates a vector of positive integers whose product is approximately equal to a target value.",
                                "Generates a vector of positive integers whose summation is approximately equal to a target value.",
                                "Generates random noise dimensions with wavy pattern generated with theta.",
                                "Generates random noise dimensions with wavy pattern generated with power functions.",
                                "Generates random noise dimensions with wavy pattern generated with power and sine functions.",
                                "Generates rotations.",
                                "Normalizes data."))
```

```{r add-tb-html, eval=knitr::is_html_output()}
add_fun_tb |> 
  kable(caption = "cardinalR additional functions", col.names = c("Function", "Explanation")) 
```

```{r add-tb-pdf, eval=knitr::is_latex_output()}
add_fun_tb |> 
  kable(caption = "cardinalR additional functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T)  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

# Application

<!-- ## Assessing the performance of dimension reduction on different geometric structures in high-dimensions -->

This section illustrates the use of package by generating a synthetic dataset to evaluate the performance of six popular dimension reduction techniques: Principal Component Analysis (PCA) [@jolliffe2011], t-distributed stochastic neighbor embedding (tSNE) [@laurens2008], uniform manifold approximation and projection (UMAP) [@leland2018], potential of heat-diffusion for affinity-based trajectory embedding (PHATE) algorithm [@moon2019], large-scale dimensionality reduction Using triplets (TriMAP) [@amid2019], and pairwise controlled manifold approximation (PaCMAP) [@yingfan2021].

The following code generates a dataset of five clusters, positioned with equal inter-cluster distances in $4\text{-}D$ space (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:highd-data)"} else { "Figure \\@ref(fig:highd-proj)"})`).

```{r gen-five-clust-data, echo=TRUE}

positions <- geozoo::simplex(p=4)$points
positions <- positions * 0.8

## To generate data
five_clusts <- gen_multicluster(n = c(2250, 1500, 750, 1250, 1750), p = 4, k = 5,
                       loc = positions,
                       scale = c(0.4, 0.35, 0.3, 1, 0.3),
                       shape = c("helicalspiral", "hemisphere", "unifcube", 
                                 "cone", "gaussian"),
                       rotation = NULL,
                       is_bkg = FALSE)
```

```{r highd-data, eval=knitr::is_html_output(), fig.cap="`langevitour` output showing five synthetic clusters with distinct geometric structures: a helical spiral, a hemisphere, a uniform cube, a cone, and a Gaussian cluster."}

langevitour::langevitour(five_clusts[, -5], group = five_clusts$cluster, levelColors = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e'))
```

```{r five-clusts-projections1}
scaled_data <- scale_data_manual(five_clusts[, -5])

## First projection
projection <- cbind(
  c(-0.59692,0.46414,0.42436,-0.10048),
  c(-0.54999,-0.67673,-0.03631,-0.01193))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj1[["cluster"]] <- as.character(five_clusts$cluster)

five_clusts_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.text = element_text(size = 10))

```

```{r five-clusts-projections2}
## Second projection
projection <- cbind(
  c(0.34673,-0.35774,0.66272,0.27298),
  c(0.24023,0.01170,-0.41886,0.72707))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.07))

proj_obj2[["cluster"]] <- as.character(five_clusts$cluster)

five_clusts_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.2), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.text = element_text(size = 10))
```

```{r five-clusts-projections3}
## Third projection
projection <- cbind(
  c(0.47388,-0.20984,-0.56560,0.41644),
  c(-0.51124,-0.60184,0.06463,0.36627))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj3[["cluster"]] <- as.character(five_clusts$cluster)

five_clusts_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.1), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.text = element_text(size = 10))

```

```{r highd-proj, eval=knitr::is_latex_output(), fig.pos='H', fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the five clusters data. The helical spiral cluster is represented in dark green, the hemisphere cluster in orange, the uniform cube-shaped cluster in purple, the blunted cone cluster in pink, and the Gaussian-shaped cluster in light green."}
#| fig-width: 15
#| fig-height: 5

five_clusts_proj1 + five_clusts_proj2 + five_clusts_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

The five clusters have different geometric structures and each contain different number of points. Specifically, the helical spiral cluster includes $2250$ points and was generated with a scale parameter of $0.4$. The hemisphere cluster consists of $1500$ points with a scale parameter of $0.35$. The uniform cube-shaped cluster contains $750$ points and uses a scale parameter of $0.3$. The blunted cone cluster includes $1250$ points, generated with a scale parameter of $1$. Finally, the Gaussian-shaped cluster contains $1750$ points and was generated with a scale parameter of $0.3$.

```{r layouts}

tsne_data <- read_rds("data/five_clusts/five_clusts_tsne_perplexity_30.rds") 

nldr1 <- tsne_data |>
  ggplot(aes(x = tSNE1,
             y = tSNE2,
             color = cluster))+
  geom_point(alpha=0.1, size=1) +
  interior_annotation("a", c(0.08, 0.93)) + 
  scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(aspect.ratio = 1,
        legend.text = element_text(size = 10)) 

umap_data <- read_rds("data/five_clusts/five_clusts_umap_n-neigbors_15_min-dist_0.1.rds") 

nldr2 <- umap_data |>
  ggplot(aes(x = UMAP1,
             y = UMAP2,
             color = cluster))+
  geom_point(alpha=0.1, size=1) +
  interior_annotation("b", c(0.08, 0.93)) + 
  scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(aspect.ratio = 1,
        legend.text = element_text(size = 10)) 

phate_data <- read_rds("data/five_clusts/five_clusts_phate_knn_5.rds") 

nldr3 <- phate_data |>
  ggplot(aes(x = PHATE1,
             y = PHATE2,
             color = cluster))+
  geom_point(alpha=0.1, size=1) +
  interior_annotation("c", c(0.08, 0.93)) + 
  scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(aspect.ratio = 1,
        legend.text = element_text(size = 10)) 

trimap_data <- read_rds("data/five_clusts/five_clusts_trimap_n-inliers_12_n-outliers_4_n-random_3.rds") 

nldr4 <- trimap_data |>
  ggplot(aes(x = TriMAP1,
             y = TriMAP2,
             color = cluster))+
  geom_point(alpha=0.1, size=1) +
  interior_annotation("d", c(0.08, 0.93)) + 
  scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(aspect.ratio = 1,
        legend.text = element_text(size = 10))  

pacmap_data <- read_rds("data/five_clusts/five_clusts_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds") 

nldr5 <- pacmap_data |>
  ggplot(aes(x = PaCMAP1,
             y = PaCMAP2,
             color = cluster))+
  geom_point(alpha=0.1, size=1) +
  interior_annotation("e", c(0.08, 0.93)) + 
  scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(aspect.ratio = 1,
        legend.text = element_text(size = 10)) 

pca_data <- read_rds("data/five_clusts/five_clusts_pca.rds") 

nldr6 <- pca_data |>
  ggplot(aes(x = pca1,
             y = pca2,
             color = cluster))+
  geom_point(alpha=0.1, size=1) +
  interior_annotation("f", c(0.08, 0.93)) + 
  scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(aspect.ratio = 1,
        legend.text = element_text(size = 10)) 
```

```{r, label = "fig-nldr-layouts", fig.pos="H", fig.cap="Six different dimension reduction representations of the five clusters data using default hyperparameter settings: (a) tSNE, (b) UMAP, (c) PAHTE, (d) TriMAP, (e) PaCMAP, and (f) PCA."}

nldr1 + nldr2 + nldr3 +
  nldr4 + nldr5 + nldr6 +
  plot_layout(ncol = 3, guides = "collect")
```

UMAP, PHATE, TriMAP, and PaCMAP effectively separate the five clusters and show the preservation of the global structure (Figure \@ref(fig:fig-nldr-layouts)). However, PHATE reveals three non-linear clusters, even though two of them do not show non-linearity. UMAP, TriMAP, and PaCMAP successfully maintain the local structures of the data. In contrast, tSNE divides the non-linear cluster into sub-clusters. Also, tSNE fails to preserve the distances between the clusters. PCA, on the other hand, preserves the local structures of the clusters, but some clusters are incorrectly merged that should remain distinct.

# Conclusion

The `cardinalR` package introduces a flexible framework for generating high-dimensional data structures with well-defined geometric properties. It addresses an important need in the evaluation of clustering, machine learning, and dimensionality reduction (DR) methods by enabling the construction of customized datasets with interpretable structures, noise characteristics, and clustering arrangements. In this way, `cardinalR` complements existing packages such as `geozoo`, `snedata`, and `mlbench`, while extending the scope to higher dimensions and more complex shapes.

The included structures cover a wide range of diagnostic settings. Branching shapes facilitate the study of continuity and topological preservation, the Scurve with a hole allows investigation of incomplete manifolds, and clustered spheres assess separability on curved surfaces. The MÃ¶bius strip introduces challenges from non-orientable geometry, while gridded cubes and pyrholes test spatial regularity and clustering in sparse, non-convex regions.

These structures are designed to support not only algorithm diagnostics, but also teaching high-dimensional concepts, benchmarking reproducibility, and evaluating hyperparameter sensitivity. By allowing users to adjust dimensionality, sample size, noise, and clustering properties, the package promotes transparent experimentation and comparative model evaluation.

Future extensions of `cardinalR` may include biologically inspired or application-driven data structures would further broaden its utility in domains such as bioinformatics, forensic science, and spatial analysis.

<!-- - Branching: These functions create a controlled environment for testing how effectively various algorithms preserve branching topology and continuity in their low-dimensional embeddings. -->

<!-- - Scurve with a hole allowing for evaluation of how well algorithms handle incomplete manifolds or missing local structure. -->

<!-- - clusteredsphere: This structure allows for cluster separation on curved manifolds in high-dimensional space and can be used to test the ability of NLDR methods and clustering algorithms to detect spherical clusters of different sizes and separations. -->

<!-- - Mobius: The core geometric structure is a Mobius stripâ€”a classic one-sided surface with a half-twistâ€”useful for evaluating how well methods capture non-orientability and twisted manifolds. -->

<!-- - Grided cube: This function is useful for assessing how algorithms preserve uniformly spaced data in high-dimensional spaces. -->

<!-- - Pyrholes: This structure is useful for testing clustering and NLDR algorithms on non-convex and sparse high-dimensional shapes. -->

<!-- The application of our high-dimensional data generation package to evaluate the interplay between dimensionality reduction, nuisance variables, and hierarchical clustering yielded several key insights. The ability to generate synthetic datasets with well-defined underlying structures, coupled with the controlled introduction of nuisance variables, provided a valuable platform for assessing the robustness of downstream unsupervised learning techniques. -->

<!-- Our findings demonstrated that the choice of dimensionality reduction method significantly impacted the ability of hierarchical clustering to recover the true underlying clusters. Methods that effectively preserved the global structure of the data, as defined by our generation process, generally led to more accurate and interpretable hierarchical clustering results. However, the presence of nuisance variables often confounded the low-dimensional embeddings, making it more challenging for hierarchical clustering to separate truly distinct groups. This highlights a critical consideration in real-world data analysis, where unmeasured or latent factors can obscure the signal of interest. -->

<!-- The hierarchical clustering analysis itself, and the choice of linkage criteria, also played a crucial role. Different linkage methods revealed varying degrees of sensitivity to the distorted representations caused by the nuisance variables. For instance, methods that prioritize compact clusters might have been more susceptible to being misled by variance introduced by nuisance factors, while others focusing on the distance between clusters might have shown more resilience. The dendrograms generated by hierarchical clustering provided a visual means to explore the relationships between samples and the potential influence of nuisance, although determining the optimal number of clusters remained a challenge in the presence of these confounding factors. -->

<!-- This application underscores the utility of our data generation package as a powerful tool for controlled experimentation in unsupervised learning. By providing the ground truth cluster assignments and the ability to systematically manipulate data characteristics like dimensionality, geometric structure, and the presence of nuisance variables, researchers can gain a deeper understanding of the strengths and limitations of various DR and clustering algorithms. This controlled environment allows for a more objective evaluation than often possible with real-world datasets where the underlying structure is unknown. -->

<!-- One limitation of this particular application was the specific type and magnitude of the nuisance variables introduced. Future work could explore a wider range of nuisance types (e.g., batch effects, technical noise with specific distributions) and their varying degrees of influence on different DR and clustering methodologies. Furthermore, investigating strategies for mitigating the impact of nuisance variables, either during the DR step or within the clustering process itself, would be a valuable extension. -->

<!-- In conclusion, this example demonstrates the critical role of synthetic data generation in dissecting the complex interactions within unsupervised learning pipelines. Our package provides a flexible and controlled means to create such data, enabling researchers to systematically evaluate the performance and robustness of dimensionality reduction and clustering algorithms under well-defined conditions, including the presence of confounding factors. This capability contributes to a more rigorous and informed approach to high-dimensional data analysis. -->

# Acknowledgements

The source material for this paper is available at [https://github.com/JayaniLakshika/paper-cardinalR](https://github.com/JayaniLakshika/paper-cardinalR).

These `R` packages were used for this work: `cli` [@gabor2025], `tibble` [@kirill2023], `gtools` [@gregory2023], `dplyr` [@hadley2023], `stats` [@core2025], `tidyr` [@hadley2024], `purrr` [@hadley2025], `mvtnorm` [@alan2009], `geozoo` [@barret2016], and `MASS` [@venables2002]. This article is created using \CRANpkg{knitr} [@yihui2015] and \CRANpkg{rmarkdown} [@yihui2018] in R with the `rjtools::rjournal_article` template. 
