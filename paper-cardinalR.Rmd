---
title: "cardinalR: Generating Interesting High-Dimensional Data Structures"
abstract: >
  Simulated high dimensional data is useful for testing, validating, and improving algorithms used in dimensionality reduction, supervised and unsupervised learning. High-dimensional data is characterized by multiple variables that are dependent or associated in some way, such as linear, nonlinear, clustering or anomalies. Here we provide new methods for generating a variety of high-dimensional structures using mathematical functions and statistical distributions organized into the R package cardinalR. Several example data sets are also provided. These will be useful for researchers to better understand how different analytical methods work and can be improved, with a special focus on nonlinear dimension reduction methods. This package enriches the existing toolset of benchmark datasets for evaluating algorithms.
draft: true
author:
  - name: Jayani P. Gamage
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: https://jayanilakshika.netlify.app/
    orcid: 0000-0002-6265-6481
    email: jayani.piyadigamage@monash.edu
  - name: Dianne Cook
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    url: http://www.dicook.org/
    email: dicook@monash.edu
    orcid: 0000-0002-3813-7155
  - name: Paul Harrison
    affiliation: Monash University
    address: MGBP, BDInstitute, VIC 3800 Australia
    email: paul.harrison@monash.edu
    orcid: 0000-0002-3980-268X
  - name: Michael Lydeamore
    affiliation: Monash University
    address: Department of Econometrics and Business Statistics, VIC 3800 Australia
    email: michael.lydeamore@monash.edu
    orcid: 0000-0001-6515-827X
  - name: Thiyanga S. Talagala
    affiliation: University of Sri Jayewardenepura
    address: Department of Statistics, Gangodawila, Nugegoda 10100 Sri Lanka
    url: https://thiyanga.netlify.app/
    email: ttalagala@sjp.ac.lk
    orcid: 0000-0002-0656-9789
type: package
creative_commons: CC BY
date: "`r Sys.Date()`"
preamble: >
  \usepackage{amsmath}
  \usepackage{array}
  \usepackage{float}
output:
  rjtools::rjournal_article:
    keep_md: true
bibliography: paper-cardinalR.bib
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
options(repos = "https://cloud.r-project.org") ## set up CRAN mirror
knitr::opts_chunk$set(
  echo = FALSE,
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE,
  out.width = "100%",
  fig.pos = "!")

```

```{r set-seed}
set.seed(20240412)
```

```{r load-libraries}
library(cardinalR)
library(tidyverse)
library(kableExtra)
library(geozoo)
library(patchwork)
library(colorspace)
library(crosstalk)
library(fpc)
library(mclust)
library(htmltools)
```

```{r}
#| label: plot-theme
theme_set(theme_linedraw() +
   theme(
     aspect.ratio = 1,
     plot.background = element_rect(fill = 'transparent', colour = NA),
     plot.title = element_text(size = 7, hjust = 0.5, vjust = -0.5),
     panel.background = element_rect(fill = 'transparent', 
                                     colour = NA),
     panel.grid.major = element_blank(), 
     panel.grid.minor = element_blank(), 
     axis.title.x = element_blank(), axis.title.y = element_blank(),
     axis.text.x = element_blank(), axis.ticks.x = element_blank(),
     axis.text.y = element_blank(), axis.ticks.y = element_blank(),
     legend.background = element_rect(fill = 'transparent', 
                                      colour = NA),
     legend.key = element_rect(fill = 'transparent', 
                               colour = NA),
     legend.position = "bottom", 
     legend.title = element_blank(), 
     legend.text = element_text(size=4),
     legend.key.height = unit(0.25, 'cm'),
     legend.key.width = unit(0.25, 'cm'),
     plot.margin = margin(0, 0, 0, 0)
   )
)
```

```{r}
#| label: import-scripts
source("scripts/additional_functions.R")
```

# Introduction

Generating synthetic datasets with clearly defined geometric properties is useful for evaluating and benchmarking algorithms in various fields, such as machine learning, data mining, and computational biology. Researchers often need to generate data with specific dimensions, noise characteristics, and complex underlying structures to test the performance and robustness of their methods. There are numerous packages available in R for generating synthetic data, each designed with unique characteristics and focus areas. The `geozoo` package [@barret2016] provides functions to generate standard high-dimensional data like cubes, spheres and simplexes, along with some prepared datasets. The `snedata` package  [@james2025] provides functions for generating common examples used in dimension reduction publications and to download benchmark data sets. The `splatter` package [@luke2017] is designed to simulate complex biological data, capturing field-specific nuances such as batch effects and differential expression. The `mlbench` package [@friedrich2024] provides access to benchmark datasets commonly associated with established classification or regression challenges. The `surreal` package [@james2024] implements the "Residual (Sur)Realism" algorithm [@leonard2007] to generate datasets that embed hidden images or text into residual plots, providing engaging visual demonstrations for teaching model diagnostics. <!--Meanwhile, the `DHARMa` package (@florian2024) adopts a simulation-based approach to create scaled quantile residuals for generalized linear (mixed) models and related frameworks, supporting model diagnostics through intuitive residuals, plots, and tests for common misspecification issues.-->

The current work implemented in the `cardinalR` R package builds on these approaches. It provides functions to generate a more extensive set of high-dimensional data structures, allowing users to: (i) construct high-dimensional datasets based on geometric shapes, including the option to enhance dimensionality by adding controlled noise dimensions; (ii) introduce adjustable levels of background noise to these structures; and (iii) combine the shapes to produce multiple clusters. The user can control characteristics such as number of dimensions, shape and sample size. It is designed to resource researchers with synthetic datasets to evaluate the performance and interpret the fit of NLDR methods, clustering algorithms, and visualization techniques. These datasets can also serve as benchmark examples for exploring how different choices of algorithm parameters affect the identification or representation of cluster and manifold structures in high-dimensional spaces.

The motivation for developing this package originated from our own work in studying nonlinear dimension reduction (NLDR) algorithms. We wanted to conduct a visualization experiment to understand perception and misperception of a variety of NLDR methods. This required simulated datasets with carefully controlled geometric and clustering properties. While some existing packages provided useful starting points, none fully supported the creation of flexible, high-dimensional data with the specific structural variations needed for our experiment. Developing these generators for research purposes underlies `cardinalR`, which is now a general-purpose package that should be useful for research and teaching.

The example data structures are best viewed using a tour [@As85]. These show the data as a sequence of low dimensional projections (typically 2D), providing a good sense of the shape in high dimensions. The interactive tour plots included in this paper are produced using the software langevitour [@paul2023].

The paper is organized as follows. In the next section, we introduce the implementation of the `cardinalR` package on GitHub, including a demonstration of the package's key functions. We illustrate how a clustering data structure affects the dimension reductions in the Application section. Finally, we give a brief conclusion of the paper and discuss potential opportunities for the use of our data collection.

# Usage

The `cardinalR` package is built on a modular framework where individual geometric generators (e.g., Gaussian, cone, sphere) create well-defined shapes (A full list of available shape generators are available at <https://jayanilakshika.github.io/cardinalR/reference/index.html>.), which can then be combined into a single dataset including scaling, rotation, and translation. The package is available on CRAN, and the source is available on GitHub at [JayaniLakshika/cardinalR](https://github.com/JayaniLakshika/cardinalR). 

The main function, `gen_multicluster()`, is an all-in-one function that includes generating individual shapes, handling scaling and rotating of these shapes, and combining the result into a single unified dataset. This function and associated workflow allow flexible construction of complex, high-dimensional structures for evaluating clustering and dimension reduction methods. Figure `r '\\@ref(fig:workflow)'` illustrates the workflow of `gen_multicluster()`.

```{r workflow, out.width = "80%", fig.align='center', fig.cap="Workflow for generating high-dimensional clustered data. The user specifies input parameters such as the number of points ($n$), number of clusters ($k$), cluster locations, shapes, scaling, rotations, and optional background noise. Each cluster shape is generated by a shape generator, optionally rotated or scaled, and combined into a single dataset. Additional background noise can be added, and each observation is labeled by shape.", fig.alt="Workflow for generating high-dimensional clustered data, from specifying input parameters to producing the final labeled dataset with optional noise dimensions.", fig.pos="!ht"}

knitr::include_graphics("figures/cardinalR_workflow.png")
```

Users can control the number of clusters (`k`), and the number of points in each cluster (`n`). Each cluster can take on a different geometric shape (e.g., Gaussian, cone, uniform cube) by specifying the corresponding generator function (`shape`), can be scaled to adjust its spread, rotated using custom rotation matrices (`rotation`), and positioned at defined centroids (`loc`). The function ensures flexibility in cluster location and orientation, allowing users to simulate complex high-dimensional structures. 

The following is an example of a three-shape multiclustered dataset. The first shape is Gaussian, the second conical, and the third a cube.

```{r, echo=TRUE}
clust_data <- gen_multicluster(
  n = c(200, 300, 500),
  k = 3,
  loc = matrix(c(
    0, 0, 0, 0,
    5, 9, 0, 0,
    3, 4, 10, 7
  ), nrow = 3, byrow = TRUE),
  scale = c(3, 1, 2),
  shape = c("gaussian", "cone", "unifcube"),
  is_bkg = FALSE
)
```

Here, the shapes have $200$, $300$, and $500$ points respectively (`n`), are positioned in $4\text{-}D$ space according to a location matrix, `loc`, and stretched according to the `scale`. The details of the individual shape generators and the noise elements are contained in the following sections.

# Implementation

The main function of the package is `gen_multicluster()`, which generates datasets consisting of multiple clusters with user-specified characteristics. 
To maintain consistency across generators, the function identifies the arguments required by each chosen generator function and supplies only those arguments that are valid for that specific generator. This design enables the combination of cluster types with differing parameter requirements within the same dataset. When clusters are generated with fewer dimensions than others, the function augments the lower-dimensional clusters with additional Gaussian noise variables so that all clusters are represented in the same dimensional space. These noise dimensions are drawn independently from normal distributions $X \sim \mathcal{N}(\mu, \sigma^2)$, where the mean ($\mu$) is set to the average of the cluster coordinates and the standard deviation ($\sigma$) defaults to $0.2$.

An optional argument, `is_bkg`, adds background noise drawn from a multivariate normal distribution centered on the dataset’s overall mean with standard deviations matching the observed spread. Extra arguments (`...`) can be passed to cluster generators, allowing further control over per-cluster characteristics like radius of the sphere. The main arguments of the `gen_multicluster()` function are shown in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:main-tb-html)', '\\@ref(tab:main-tb-pdf)'))`.

```{r}
main_tb <- tibble(arg = c("n",
                          "k",
                          "loc",
                          "scale",
                          "shape",
                          "rotation",
                          "is_bkg"),
                  type = c("numeric (vector)",
                           "numeric",
                           "numeric (matrix)",
                           "numeric (vector)",
                           "character (vector)",
                           "numeric (list)",
                           "boolean"),
                        exp = c("Number of points in each cluster.",
                                "Number of clusters.",
                                "Locations/centroids of clusters.",
                                "Scaling factors of clusters.",
                                "Shapes of clusters.",
                                "Rotation matrices, one per cluster.",
                                "Background noise should exist or not.")) |> 
    mutate(arg = gsub("_", "\\\\_", arg))
```

```{r main-tb-html, eval=knitr::is_html_output()}
main_tb |> 
  mutate(arg = paste0("<code>", arg, "</code>")) |> 
  kable(caption = "The main arguments for `gen_multicluster()`.", col.names = c("Argument", "Type", "Explanation"), linesep = "", escape = FALSE, table.pos = "!ht") 
```

```{r main-tb-pdf, eval=knitr::is_latex_output()}
main_tb |> 
    mutate(arg = paste0("\\texttt{", arg, "}")) |> 
  kable(caption = "The main arguments for \\texttt{gen\\_multicluster()}.", format="latex", col.names = c("Argument", "Type", "Explanation"), booktabs = T, table.pos = "!ht", linesep = "", escape = FALSE)  |>
  column_spec(1, width = "2cm") |>
  column_spec(2, width = "3cm") |>
  column_spec(3, width = "8cm")
```

## Shape generators

The shape generators form the foundation of the package, providing functions to create synthetic datasets from simple, well-defined geometric forms such as cones, pyramids, spheres, grids, and branching structures. Each generator includes the parameter `n`, which specifies the number of points to generate. Some functions, such as `gen_unifcube()`, also take the dimension `p`, while others include arguments specific to the geometry (e.g., radius for spheres (`r`), width for bands (`w`)). If higher-dimensional data are required, additional noise dimensions can be appended after data generation using any noise generator function. This flexibility allows users to construct both low- and high-dimensional datasets from the same underlying structures. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:shape-tb-html)', '\\@ref(tab:shape-tb-pdf)'))` outlines these functions. The main arguments of the functions described in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:arg-shape-tb-html)', '\\@ref(tab:arg-shape-tb-pdf)'))`.

```{r}
shape_tb <- tibble(fun = c("gen_expbranches",
                             "gen_linearbranches",
                             "gen_curvybranches", 
                             "gen_orglinearbranches", 
                             "gen_orgcurvybranches",
                             "gen_cone",
                             "gen_gridcube",
                             "gen_unifcube",
                            "gen_gaussian",
                            "gen_longlinear",
                            "gen_mobius",
                            "gen_quadratic",
                             "gen_cubic",
                            "gen_pyrrect",
                             "gen_pyrtri",
                             "gen_pyrstar",
                             "gen_pyrfrac",
                            "gen_scurve",
                            "gen_circle",
                            "gen_curvycycle",
                            "gen_unifsphere",
                            "gen_hollowsphere",
                            "gen_gridedsphere",
                            "gen_clusteredspheres",
                            "gen_hemisphere",
                            "gen_swissroll",
                            "gen_trefoil4d",
                            "gen_trefoil3d",
                             "gen_crescent",
                            "gen_curvycylinder",
                            "gen_sphericalspiral",
                            "gen_helicalspiral",
                            "gen_conicspiral",
                            "gen_nonlinear"),
                    parm = c("n, k",
                             "n, k",
                             "n, k",
                             "n, p, k",
                             "n, p, k",
                             "n, p, h, ratio",
                             "n, p",
                             "n, p",
                             "n, p, s",
                             "n, p",
                             "n",
                             "n",
                             "n",
                             "n, p",
                             "n, p",
                             "n, p",
                             "n, p",
                              "n",
                             "n, p",
                             "n, p",
                             "n, r",
                             "n, p",
                             "n",
                             "n, k, r, loc",
                             "n, p",
                             "n, w",
                             "n, steps",
                             "n, steps",
                             "n", 
                             "n, h", 
                             "n, spins", 
                             "n", 
                             "n, spins", 
                             "n, hc, non_fac"),
                      exp = c("Exponential shaped branches.",
                               "Linear shaped branches.", 
                               "Curvy shaped branches.",
                               "Linear shaped branches originated in one point.",
                               "Curvy shaped branches originated in one point.",
                               "Cone-shaped structure.",
                              "Cube with specified grid points along each axes.",
                              "Cube with uniform points.",
                              "Multivariate Gaussian cloud.",
                              "Long linear structure.",
                              "Möbius strip in $3\text{-}D$.",
                              "Quadratic pattern in $2\text{-}D$.",
                                "Cubic pattern in $2\text{-}D$.",
                              "Rectangular-base, with a sharp or blunted apex.",
          "Triangular-base, with a sharp or blunted apex.",
          "Star-shaped base, with a sharp or blunted apex.",
          "Pyramid with triangular pyramid-shaped holes.",
          "S-curve in $3\text{-}D$.",
          "Circle.",
                                "Curvy cell cycle.",
                                "Uniform ball.",
                                "Hollow sphere.",
                                "Grided sphere.",
                                "Multiple small spheres within a big sphere.",
                                "Hemisphere.",
          "Swissroll structure.",
          "Trefoil in $4\\text{-}D$.", 
          "Trefoil in $3\\text{-}D$.",
          "Crescent pattern.",
                                "Curvy cylinder.",
                                "Spherical spiral.",
                                "Helical spiral.",
                                "Conic spiral.",
                                "Nonlinear hyperbola.")) |> 
   mutate(fun = gsub("_", "\\\\_", fun)) |> 
   mutate(parm = gsub("_", "\\\\_", parm))
```

```{r shape-tb-html, eval=knitr::is_html_output()}
shape_tb |> 
  mutate(parm = paste0("<code>", parm, "</code>")) |>
  mutate(fun = paste0("<code>", fun, "</code>")) |> 
  kable(caption = "Overview of shape-generation functions, including their required parameters and a brief description of each geometric structure produced. The generators cover branching patterns, spheres, spirals, pyramids, Gaussian clouds, and other nonlinear shapes.", col.names = c("Function", "Arguments", "Explanation"), escape = FALSE, table.pos = "!ht") 
```

```{r shape-tb-pdf, eval=knitr::is_latex_output()}
shape_tb |>
  mutate(parm = paste0("\\texttt{", parm, "}")) |>
  mutate(fun = paste0("\\texttt{", fun, "}")) |> 
  kable(caption = "Overview of shape-generation functions, including their required parameters and a brief description of each geometric structure produced. The generators cover branching patterns, spheres, spirals, pyramids, Gaussian clouds, and other nonlinear shapes.", format="latex", col.names = c("Function", "Arguments", "Explanation"), escape = FALSE, booktabs = T, table.pos = "!ht", linesep = "")  |>
  column_spec(1, width = "3.5cm") |>
  column_spec(2, width = "1.5cm") |>
  column_spec(3, width = "8cm")
```

```{r}
arg_branching_tb <- tibble(arg = c("n", "k", "p", "h", "ratio", "s", "r", "n_vec", "k_small", "r_vec", "spe", "w", "steps", "spins", "hc", "non_fac"), 
                          type = c("integer", "integer", "integer", "real value",
                                   "real value", "real value", "real value", "integers", "integer", "real values", "real value", "real value", "integer", "integer", "real value", "real value"),
                        exp = c("Number of points.",
                                "Number of clusters.",
                                "Number of dimensions.",
                                "Height.",
                                "Radius tip to radius base ratio.",
                                "Variance-covariance matrix.",
                                "Radius.",
                                "Sample sizes of the big and small spheres",
                                "Number of small spheres.",
                                "Radius of the big and small spheres.",
                                "How far apart the small spheres are placed.",
                                "Vertical variation",
                                "Number of steps for the theta parameter.",
                                "Number of loops of the spiral.",
                                "Steepness and vertical scaling of the hyperbola.",
                                "Strength of this sinusoidal effect.")) |> 
   mutate(arg = gsub("_", "\\\\_", arg))
```

```{r arg-shape-tb-html, eval=knitr::is_html_output()}
arg_branching_tb |> 
  mutate(arg = paste0("<code>", arg, "</code>")) |>
  kable(caption = "Argument definitions for the shape generators. The table lists each argument, its data type, and a description of its role in controlling geometric structure, dimensionality, scaling, curvature, spacing, and other features of the simulated high-dimensional datasets.", col.names = c("Argument", "Type (positive)", "Explanation"), escape = FALSE, table.pos = "!ht") 
```

```{r arg-shape-tb-pdf, eval=knitr::is_latex_output()}
arg_branching_tb |> 
  mutate(arg = paste0("\\texttt{", arg, "}")) |> 
  kable(caption = "Argument definitions for the shape generators. The table lists each argument, its data type, and a description of its role in controlling geometric structure, dimensionality, scaling, curvature, spacing, and other features of the simulated high-dimensional datasets.", format="latex", col.names = c("Argument", "Type (positive)", "Explanation"), booktabs = T, escape = FALSE, table.pos = "!ht")  |>
  column_spec(1, width = "1cm") |>
  column_spec(1, width = "2cm") |>
  column_spec(2, width = "3cm")
```

### Branching

A branching structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch)"} else { "Figure \\@ref(fig:branch-proj)"})`) captures trajectories that diverge or bifurcate from a common origin, similar to processes such as cell differentiation in biology [@trapnell2014]. We introduce a set of data generation functions specifically designed to simulate high-dimensional branching structures with various geometries, numbers of points (`n`), and number of branches (`k`). Although these functions can generate multiple branches, they do not produce a formal *multicluster* dataset: the branches form a single connected structure, with multiple visually distinct arms rather than independent clusters. 

The simplest structures are approximately linear branches in $2\text{-}D$, generated by the `gen_linearbranches(n, k)` function. These consist of $k$ short line segments in the first two dimensions, with added jitter to simulate variability. Mathematically, each branch $i$ is defined as

$$
X_1 \sim U(a_i, b_i), \quad X_2 = s_i (X_1 - x_{\text{start},i}) + y_{\text{start},i} + \epsilon, \quad \epsilon \sim U(0, \delta),
$$

where $(x_{\text{start},i}, y_{\text{start},i})$ is the starting point of branch $i$, $\delta$ controls local jitter, and $s_i$ is the slope, initialized as

$$
s_i =
\begin{cases}
0.5 & i = 1, \\
-0.5 & i = 2, \\
\text{randomly sampled from } [s_{\min}, s_{\max}] & i = 3, \dots, k.
\end{cases}
$$

Branches $1$ and $2$ are initialized with fixed slopes and intercepts, while later branches are iteratively added at locations chosen to avoid overlap with existing branches, producing a set of connected linear paths. 

```{r data-linearbranches}
linearbranches <- gen_linearbranches(n = 1000, k = 4)
```

To introduce curvature, the `gen_curvybranches(n, k)` function generates $k$ curvilinear branches in $2\text{-}D$. Branches $1$ and $2$ are simple parabolas defined as

$$
\begin{aligned}
\text{Branch 1: } & X_1 \sim U(0,1), \quad X_2 = 0.1 X_1 + X_1^2 + \epsilon, \\
\text{Branch 2: } & X_1 \sim U(-1,0), \quad X_2 = 0.1 X_1 - 2 X_1^2 + \epsilon, \quad \epsilon \sim U(0, \delta),
\end{aligned}
$$

where $\delta$ controls local jitter. Additional branches are attached iteratively to existing structures. Each new branch $i$ starts at a selected point $(x_{\text{start},i}, y_{\text{start},i})$ from the current structure and extends according to

$$
X_1 \sim U(x_{\text{start},i}, x_{\text{start},i}+1), \quad X_2 = 0.1 X_1 - s_i (X_1^2 - x_{\text{start},i}) + y_{\text{start},i},
$$

where $s_i$ is a scale factor controlling the curvature of branch $i$. For the first few initial branches, $s_i$ can be fixed (e.g., $s_1 = 1, s_2 = 2$), while for subsequent branches it is sampled from a predefined set, such as $s_i \in \{-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5\}$, to create variability in curvature. 

```{r data-curvybranches}
curvybranches <- gen_curvybranches(n = 1000, k = 4)
```

The `gen_expbranches(n, k)` function creates $k$ exponential branches in $2\text{-}D$, radiating from a central region. Each branch $i$ is defined as

$$
X_1 \sim U(-2,2), \quad X_2 = \exp(\sigma_i \, s_i \, X_1) + \epsilon, \quad \epsilon \sim U(0, \delta), \quad s_i \sim U(0.5,2),
$$

where $\sigma_i = (-1)^{i+1}$ alternates the sign of the exponent to produce mirror-symmetric branches. The parameter $s_i$ controls the steepness of branch $i$, and $\delta$ introduces small local jitter.

```{r data-expbranches}
expbranches <- gen_expbranches(n = 1000, k = 4)
```

High-dimensional generalizations are provided by `gen_orglinearbranches(n, p, k)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch)"} else { "Figure \\@ref(fig:branch-proj)"})`) and `gen_orgcurvybranches(n, p, k)`. Each branch is embedded in a unique or repeated $2\text{-}D$ subspace of the $p\text{-}D$ space. When `allow_share = TRUE`, multiple branches may share the same subspace; otherwise, subspaces are sampled without replacement until all possible $\binom{p}{2}$ combinations are exhausted, after which additional branches may repeat subspaces. Linear branches follow

$$
X_{i_1} \sim U(a_i,b_i), \quad X_{i_2} = s_i X_{i_1} + \epsilon, \quad \epsilon \sim N(0, \sigma^2),
$$

while curvilinear branches include a quadratic term

$$
X_{i_1} \sim U(a_i,b_i), \quad X_{i_2} = - s_i X_{i_1}^2 + \epsilon, \quad \epsilon \sim N(0, \sigma^2),
$$

where $a_i, b_i$ define the range of the first coordinate for branch $i$, and $\epsilon$ is Gaussian noise added to introduce variability. The scale factor $s_i$ controls slope (linear branches) or curvature (curvilinear branches) and is assigned as follows: for the first $\binom{p}{2}$ branches, $s_i = 1$; for additional branches when $k > \binom{p}{2}$, $s_i$ is randomly drawn from the set $\{1, 1.5, 2, \dots, 8\}$.

```{r data-orglinearbranches}
orglinearbranches <- gen_orglinearbranches(n = 1000, p = 4, k = 4)
```

```{r}
orglinearbranches_lang <- langevitour::langevitour(orglinearbranches, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r orglinearbranches-proj1}
scaled_data <- scale_data_manual(orglinearbranches)

## First projection
projection <- cbind(
    c(-0.083573,-0.019043,0.006574,-0.035774),
    c(0.005380,0.068541,-0.030810,-0.054717))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.8, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.15,
                                              axis_scaled = 10, 
                                              axis_pos_x = -0.12, 
                                              axis_pos_y = -0.12, 
                                              threshold = 0.015))

orglinearbranches_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.15, 0.15), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r orglinearbranches-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

orglinearbranches_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r orglinearbranches-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

orglinearbranches_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.62), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r data-orgcurvybranches}
orgcurvybranches <- gen_orgcurvybranches(n = 1000, p = 4, k = 4)
```

```{r branch, eval=knitr::is_html_output(), fig.cap="Viewing the $4\\text{-}D$ `orgcurvybranches` data. The tour view shows how the linear branches appear from multiple viewing angles.", fig.alt="Interactive langevitour of the orglinearbranches dataset in $4\\text{-}D$, showing linear branches from multiple viewing angles.", fig.pos="!ht", layout="l-body"}

branchfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;",
    orglinearbranches_lang
  ),
  device = "xs"
)

class(branchfig) <- c(class(branchfig), "htmlwidget")

branchfig
```

```{r branch-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from the $4\\text{-}D$ \\texttt{orgcurvybranches} data. Each shows a different projection, illustrating how the linear branches appear from multiple viewing angles. These views highlight the dataset’s underlying branching structure and demonstrate how projections reveal patterns that are otherwise hidden in higher dimensions.", fig.width=12, fig.height=4, fig.pos="H", fig.alt="Three $2\\text{-}D$ projections of the $4\\text{-}D$ orglinearbranches dataset, showing different angles of the linear branches to illustrate the branching structure.", fig.pos="!ht"}

orglinearbranches_proj1 + orglinearbranches_proj2 + orglinearbranches_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

### Cone

To simulate a cone-shaped structure in arbitrary dimensions (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:cone)"} else { "Figure \\@ref(fig:cone-proj)"})`), we define a function `gen_cone(n, p, h, ratio)`, which creates a high-dimensional cone with options for a sharp or blunted apex, allowing for a dense concentration of points near the tip.

This function generates $n$ points in $p\text{-}D$, where the last dimension, $X_p$, represents the height along the cone's axis, and the first $p-1$ dimensions define a shrinking hyperspherical cross-section toward the tip. Heights are sampled from a truncated exponential distribution, $X_p \sim \text{Exp}(\lambda = 2/h)$, capped at the cone height $h$, producing a higher density of points near the tip. At each height $X_p$, the radius of the cross-section decreases linearly from base to tip according to $r = r_{\text{min}} + (r_{\text{max}} - r_{\text{min}}) X_p / h$, where $r_{\text{min}} = \text{ratio}$ and $r_{\text{max}} = 1$.

For each point, a direction in the first $p-1$ dimensions is sampled uniformly on a $(p-1)$-dimensional hypersphere using generalized spherical coordinates. The radial coordinates are scaled by the height-dependent radius $r$, producing the conical taper. In three dimensions ($p = 3$), this results in a classical $3\text{-}D$ cone, while for $p > 3$, additional dimensions provide a smooth embedding into higher-dimensional space, preserving the conical structure.

```{r data-bluntedcone}
cone <- gen_cone(n = 1000, p = 4, h = 5, ratio = 0.5)
```

Cone-shaped structures appear in particle dispersions, light beams, and tapering processes, where spread decreases along one axis. They are also used to benchmark clustering and dimensionality reduction methods [@hadsell2006].

```{r}
cone_lang <- langevitour::langevitour(cone, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r cone-proj1}
scaled_data <- scale_data_manual(cone)

## First projection
projection <- cbind(
  c(0.22417,-0.02943,-0.02870,0.08418),
  c(-0.02715,0.18019,0.05053,0.15254))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.25,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.2, 
                                              axis_pos_y = -0.2, 
                                              threshold = 0.022))

cone_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.25, 0.25), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cone-proj2}

## Second projection
projection <- cbind(
    c(0.15591,0.17907,0.03198,0.04496),
    c(-0.15376,0.10435,0.15766,0.00547))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.1,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.08, 
                                              axis_pos_y = -0.08, 
                                              threshold = 0.01))

cone_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.1, 0.12), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cone-proj3}

## Third projection
projection <- cbind(
    c(-0.13548,0.13832,0.05991,-0.13544),
    c(0.08479,-0.10719,-0.01572,-0.20123))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.25,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.016))

cone_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.3, 0.2), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r cone, eval=knitr::is_html_output(), fig.cap="Viewing the $3\\text{-}D$ output  of `cone` data. Points are concentrated near the tip along the height dimension, while the radius of the hyperspherical cross-section decreases linearly toward the apex.", fig.alt="Interactive langevitour of the cone dataset in 3-D, showing points concentrated near the tip with radius decreasing linearly toward the apex.", fig.pos="!ht"}

conefig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;",
    cone_lang
  ),
  device = "xs"
)

class(conefig) <- c(class(conefig), "htmlwidget")

conefig
```

```{r cone-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from the $3\\text{-}D$ \\texttt{cone} data. Points are concentrated near the tip along the height dimension, while the radius of the hyperspherical cross-section decreases linearly toward the apex. These projections show how the conical geometry is preserved.", fig.pos="H", fig.alt="Three $2\\text{-}D$ projections of the 3-D cone dataset, showing points concentrated near the tip and the linear decrease in radius toward the apex.", fig.pos="!ht", fig.width=12, fig.height=4}

cone_proj1 + cone_proj2 + cone_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

### Cube

A cube structure represents uniformly or systematically distributed points within a high-dimensional hypercube, providing a useful framework for assessing how well algorithms preserve uniformity, and boundary properties in high dimensions. We provide a set of functions to generate high-dimensional cube structures with flexible configurations, including regular grids, and uniform random points. 

The function `gen_gridcube(n, p)` is a wrapper around `geozoo::cube.solid.grid()`. It generates a regular lattice of points in $p\text{-}D$, producing a uniform hypercube grid. Each axis contains equally spaced coordinates, resulting in a well-defined geometric structure.

```{r data-gridcube}
gridcube <- gen_gridcube(n = 1000, p = 4)
```

By contrast, `gen_unifcube(n, p)` wraps `geozoo::cube.solid.random()`, producing uniformly distributed points within a $p\text{-}D$ cube. To avoid including the cube’s vertices, these points are removed after generation. This results in a hypercube filled with random, but evenly distributed, samples rather than structured lattice points.

```{r data-unifcube}
unifcube <- gen_unifcube(n = 1000, p = 4)
```

Such cube-based structures are commonly used as benchmarks in Monte Carlo sampling, computational geometry, and density estimation, where assessing how algorithms behave under uniform or grid-like distributions is critical [@devroye1986; @niederreiter1992].

### Gaussian

The `gen_gaussian(n, p, s)` function generates a multivariate Gaussian cloud in $p\text{-}D$, centered at the origin with user-defined covariance structure. Each point is independently drawn using the multivariate normal distribution with $X_i \sim N_p(\boldsymbol{0}, s)$, where $s$ is a user-defined $p \times p$ positive-definite matrix.

```{r data-gau}
gau <- gen_gaussian(n = 1000, p = 4, s = diag(4))
```

Gaussian clouds are common benchmark structures in statistics and machine learning, used in clustering, classification, and anomaly detection, with applications in image segmentation, speech recognition, and forensic analysis [@geoffrey2000].

### Linear

<!-- The `gen_longlinear(n, p)` function generates a high-dimensional dataset representing a long linear structure with noise. Each variable is formed as $X_i = \text{scale}_i \cdot (0,1,\dots,n{-}1 + \epsilon) + \text{shift}_i$, where $\text{scale}\_i \sim U(-10, 10)$ determines the orientation of the line in each dimension, $\text{shift}\_i \sim U(-300, 300)$ offsets the line to separate dimensions, and $\epsilon \sim N(0, (0.03n)^2)$ introduces Gaussian noise.  -->

The `gen_longlinear(n, p)` function generates a high-dimensional dataset representing a long linear structure with noise. Each variable is constructed by first creating a sequence of integers from $0$ to $n-1$, adding Gaussian noise with standard deviation $0.03n$, and then applying a random scaling and shift. Specifically, for the $j$-th dimension, a scale factor $\text{scale}_j \sim U(-10, 10)$ determines the orientation and stretching of the line, while a shift factor $\text{shift}_j \sim U(-300, 300)$ is added inside the multiplication to offset the line. This results in each variable being of the form $X_j = \text{scale}_j \cdot \big((0,1,\dots,n-1) + \epsilon + \text{shift}_j\big)$, where $\epsilon \sim N(0, (0.03n)^2)$ is independent Gaussian noise. 

```{r data-linear}
linear <- gen_longlinear(n = 1000, p = 4)
```

This structure appears in $p\text{-}D$ data when variation is driven by a single factor, such as time-course or sensor measurements, providing a useful test case for trajectory and regression methods [@trapnell2014].

### Möbius

The `gen_mobius()` function is a wrapper around `geozoo::mobius()`, designed to simplify the generation of a Möbius strip in three dimensions for use in high-dimensional diagnostic studies. The function returns a tibble with $n$ sampled points forming the surface of a Möbius strip.

```{r data-mobius}
mobius <- gen_mobius(n = 1000)
```

The Möbius strip structure can model twisted or cyclic surfaces in physics and engineering, such as conveyor belts, molecular structures, or optical systems with non-orientable geometries [@optica2023].

### Polynomial

A polynomial structure generates data points that follow non-linear curvilinear relationships, such as quadratic or cubic trends, in  space. To extend these patterns into high-dimensional settings, additional noise dimensions can be added. These patterns are useful for evaluating how well algorithms capture smooth, non-linear trajectories and curvature in the data. We provide functions for generating quadratic and cubic structures, enabling controlled experiments with different degrees of polynomial complexity. 

The first is the quadratic curve of $n$ points in two dimensions. This is generated using `gen_quadratic(n, range)`. The independent variable is defined as $X_1 \sim U(\text{range}[1], \text{range}[2])$, and a raw polynomial basis of degree 2 is applied to form $X_2 = X_1 - X_1^2 + \varepsilon_2$, where $\varepsilon_2 \sim U(0, 0.5)$. This produces a smooth parabolic arc opening downward, with vertical jitter introduced by the noise term.

```{r data-quadratic}
quadratic <- gen_quadratic(n = 1000)
```

The second is the cubic curve of $n$ points in two dimensions. This is generated using `gen_cubic(n, range)`. The independent variable is defined as $X_1 \sim U(\text{range}[1], \text{range}[2])$, and a raw polynomial basis of degree $3$ is applied to construct $X_2 = X_1 + X_1^2 - X_1^3 + \varepsilon_2$, where $\varepsilon_2 \sim U(0, 0.5)$. This produces a more complex curvilinear structure than the quadratic case, with both upward and downward turning points.

```{r data-cubic}
cubic <- gen_cubic(n = 1000)
```

### Pyramid

A pyramid structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr)"} else { "Figure \\@ref(fig:pyr-proj)"})`) represents data arranged around a central apex and base, useful for exploring how algorithms handle pointed or layered geometries in $p\text{-}D$ space. The functions provided allow users to generate pyramids with rectangular, triangular, and star-shaped bases, and sharp or blunted apexes. Additionally, it is possible to create a pyramid with a fractal-like internal structure, enabling the study of non-convex and sparse regions. 

Let $X_1, \dots, X_p$ denote the coordinates of the generated points. For the rectangular, triangular, and star-shaped based pyramid generator functions, the final dimension, $X_p$, encodes the height of each point and is drawn from an exponential distribution capped at the maximum height $h$. That is, $X_p = z \sim \min\left(\text{Exp}(\lambda = 2/h),\ h\right).$ This distribution creates a natural skew toward smaller height values, resulting in a denser concentration of points near the pyramid's apex. For the star-shaped base pyramid, the final dimension is drawn from a uniform distribution. That is, $X_p = z \sim U(0, h)$.

The remaining dimensions are based on the specific pyramid shape. For the rectangular based pyramid, `gen_pyrrect(n, p, h, l_vec, rt)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) a"} else { "Figure \\@ref(fig:pyr-proj) a"})`), let $r_x(z)$ and $r_y(z)$ denote the half-widths of the rectangular cross-section at height $z$. That is, $r_x(z) = r_t + (l_x - r_t)z/h$, $r_y(z) = r_t + (l_y - r_t)z/h$. The first three coordinates are then defined as $X_1 \sim U(-r_x(z),\ r_x(z)), \quad X_2 \sim U(-r_y(z),\ r_y(z)),\text{ and }X_3 \sim U(-r_x(z),\ r_x(z)).$

```{r data-pyrrect}
pyrrect <- gen_pyrrect(n = 1000, p = 4)
```

```{r}
pyrrect_lang <- langevitour::langevitour(pyrrect, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r pyrrect-proj1}
scaled_data <- scale_data_manual(pyrrect)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

pyrrect_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrrect-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.7, 
                                              axis_pos_x = -0.45, 
                                              axis_pos_y = -0.45, 
                                              threshold = 0.08))

pyrrect_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrrect-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

pyrrect_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.75), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For the triangular based pyramid, `gen_pyrtri(n, p, h, l, rt)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) b"} else { "Figure \\@ref(fig:pyr-proj) b"})`), let $r(z)$ denote the scaling factor (distance from the origin to triangle vertices) at height $z$. That is, $r(z) = r_t + (l-r_t)z/h$. A point in the triangle at height $z$ is generated using barycentric coordinates $(u, v)$ to ensure uniform sampling within the triangular cross-section: $u, v \sim U(0, 1), \quad \text{if } u + v > 1: u \leftarrow 1 - u,\ v \leftarrow 1 - v$. The first three coordinates (triangle plane) are then: $X_1 = r(z)(1 - u - v)$, $X_2 = r(z)u$, and $X_3 = r(z)v.$ 

```{r data-pyrtri}
pyrtri <- gen_pyrtri(n = 1000, p = 4)
```

```{r}
pyrtri_lang <- langevitour::langevitour(pyrtri, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r pyrtri-proj1}
scaled_data <- scale_data_manual(pyrtri)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.3,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.2, 
                                              axis_pos_y = -0.2, 
                                              threshold = 0.022))

pyrtri_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.25, 0.3), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrtri-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.3,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.03))

pyrtri_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.3, 0.4), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrtri-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

pyrtri_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For the star based pyramid, `gen_pyrstar(n, p, h, rb)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) c"} else { "Figure \\@ref(fig:pyr-proj) c"})`), let the radius at height $z$, $r(z)$, be such that the radius scales linearly from zero (tip) to the base radius $r_b$. That is, $r(z) = r_b\left(1 - z/h\right)$. Each point is placed within a regular hexagon in the plane $(X_1, X_2)$, using a randomly chosen hexagon sector angle $\theta \in \{0, \pi/3, 2\pi/3, \pi, 4\pi/3, 5\pi/3\}$ and a uniformly random radial scaling factor: $\theta \sim \text{Uniform sample from 6 hexagon angles}$, $r_{\text{point}} \sim \sqrt{U(0, 1)}$. Then, the first two coordinates are: $X_1 = r(z)r_{\text{point}}\cos(\theta)$, and $X_2 = r(z)r_{\text{point}}\sin(\theta)$.

```{r data-pyrstar}
pyrstar <- gen_pyrstar(n = 1000, p = 4)
```

```{r}
pyrstar_lang <- langevitour::langevitour(pyrstar, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r pyrstar-proj1}
scaled_data <- scale_data_manual(pyrstar)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

pyrstar_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrstar-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

pyrstar_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.4), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrstar-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

pyrstar_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For rectangular and triangular pyramids, the remaining dimensions $X_4$ to $X_{p-1}$, and for star-based pyramids $X_3$ to $X_{p-1}$, are treated as noise.

Finally, for the Sierpinski-like pyramid, `gen_pyrfrac(n, p)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:pyr) d"} else { "Figure \\@ref(fig:pyr-proj) d"})`), let $X_1, X_2, \dots, X_p$ denote the coordinates of the generated points. The generation process begins with an initial point $T_0 \in [0, 1]^p$ drawn from a uniform distribution: $T_0 \sim U(0, 1)^p$. Let $C_1, C_2, \dots, C_{p+1}$ denote the corner vertices of a $p\text{-}D$ simplex. At each iteration $i = 1, \dots, n$, a new point is computed by taking the midpoint between the previous point $T_{i-1}$ and a randomly selected vertex $C_k$: $T_i = 1/2(T_{i-1} + C_k), \quad C_k \in \{C_1, \dots, C_{p+1}\}$. This recursive midpoint rule generates self-similar patterns with systematic voids (holes) between clusters of points. The points remain bounded inside the convex hull of the simplex. The final output is a $n \times p$ matrix where each row represents a point: $X = \{T_1, T_2, \dots, T_n\}, \quad X \in \mathbb{R}^{n \times p}$.

```{r data-pyrholes}
pyrholes <- gen_pyrfrac(n = 1000, p = 4)
```

```{r}
pyrholes_lang <- langevitour::langevitour(pyrholes, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r pyrholes-proj1}
scaled_data <- scale_data_manual(pyrholes)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

pyrholes_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "d1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrholes-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

pyrholes_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.75), 
  title = "d2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r pyrholes-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

pyrholes_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "d3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Pyramid structures mimic tapering or layered geometries seen in architecture, crystals, and fractal-like natural patterns [@kirkby1983].

```{r pyr, eval=knitr::is_html_output(), fig.cap="Viewing the $4\\text{-}D$  `pyrrect`, `pyrtri`, `pyrstar`, and `pyrholes` data. The `pyrrrect` structure forms a dense rectangular base tapering to a narrow tip, while `pytri` shows a more triangular spread with sharper edges. `Pyrstar` extends into multiple pointed branches radiating from a common core, and `pyrholes` reveals hollow or open regions within an otherwise compact shape.", fig.alt="Interactive langevitour of four $4\\text{-}D$ pyramid-like datasets: pyrrect, pyrtri, pyrstar, and pyrholes, showing dense bases, triangular spreads, branching points, and hollow regions.", fig.pos="!ht"}

pyrfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;",
    pyrrect_lang, pyrtri_lang, pyrstar_lang, pyrholes_lang
  ),
  device = "xs"
)

class(pyrfig) <- c(class(pyrfig), "htmlwidget")

pyrfig
```

```{r pyr-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the \\texttt{pyrrect} (a1-a3), \\texttt{pyrtri} (b1-b3), \\texttt{pyrstar} (c1-c3), and \\texttt{pyrholes} (d1-d3) data. The \\texttt{pyrrrect} structure forms a dense rectangular base tapering to a narrow tip, while \\texttt{pytri} shows a more triangular spread with sharper edges. \\texttt{pyrstar} extends into multiple pointed branches radiating from a common core, and \\texttt{pyrholes} reveals hollow or open regions within an otherwise compact shape. These projections illustrate a range of pyramid-like geometries that vary in density and structure.", fig.width=12, fig.height=16, fig.pos="H", out.width="80%", fig.align='center', fig.alt="Three $2\\text{-}D$ projections from each of four $4\\text{-}D$ pyramid-like datasets: pyrrect, pyrtri, pyrstar, and pyrholes, showing their distinct geometries, branching, and hollow regions.", fig.pos="!ht"}

pyrrect_proj1 + pyrrect_proj2 + pyrrect_proj3 +
pyrtri_proj1 + pyrtri_proj2 + pyrtri_proj3 +
pyrstar_proj1 + pyrstar_proj2 + pyrstar_proj3 +
pyrholes_proj1 + pyrholes_proj2 + pyrholes_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

### S-curve

The S-curve is a smooth, non-linear manifold in $3\text{-}D$ space. Using `gen_scurve(n)`, it is defined by $X_1 = \sin(\theta), \quad X_2 \sim U(0, 2), \quad X_3 = \text{sign}(\theta)(\cos(\theta) - 1), \quad \theta \sim U(-3\pi/2, 3\pi/2).$

This follows the `s_curve()` function from snedata [@james2025], itself adapted from *scikit-learn*, but differs by returning a tibble with standardized names (`x1`, `x2`, `x3`), excluding the color variable, and omitting built-in noise (which can be added separately). S-curve is commonly used in manifold learning and dimension reduction as benchmarks for unfolding curved structure.

```{r data-scurve}
scurve <- gen_scurve(n = 1000)
```

### Sphere

Sphere-shaped structures are useful for evaluating how dimension reduction and clustering algorithms handle curved, symmetric manifolds in high-dimensional spaces. Throughout this section, we follow the standard mathematical terminology: a *sphere* refers to the hollow $(p-1)$-dimensional surface in $\mathbb{R}^p$, while a *ball* refers to the filled interior region. The functions generate a variety of spherical forms, including simple circles, uniform and hollow spheres, grid-based spheres, and complex arrangements like clustered spheres within a larger sphere. The first few coordinates define the main geometric form (circle, cycle, sphere, or hemisphere), while higher-dimensional embeddings are achieved by adding noise dimensions. Such spherical or hemispherical structures frequently appear in physical and biological systems, for example in models of celestial bodies, molecular shells, or cell membranes [@tinkham2003; @alberts2014].

The simplest case, `gen_circle(n, p)` creates a unit circle in two dimensions, with the remaining dimensions forming sinusoidal extensions of the angular parameter at progressively smaller scales (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) a"} else { "Figure \\@ref(fig:sphere-proj) a"})`). Let a latent angle variable $\theta$ is uniformly sampled from the interval $[0, 2\pi]$. Coordinates in the first two dimensions represent a perfect circle on the plane: $$X_1 = \cos(\theta), \quad X_2 = \sin(\theta).$$ For dimensions $X_3$ through $X_p$, sinusoidal transformations of the angle $\theta$ are introduced. The first component is a scaling factor that decreases with the dimension index, defined as $\text{scale}_j = \sqrt{(0.5)^{j-2}}$ for $j = 3, \dots, p$. The second component is a phase shift that is proportional to the dimension index, specifically designed to decorrelate the curves, given by the formula $\phi_j = (j - 2)\pi/2p$. Each additional dimension is computed as: $X_j = \text{scale}_{j}\sin(\theta + \phi_j), \quad j = 3, \dots, p$.

```{r data-circle}
circle <- gen_circle(n = 1000, p = 4)
```

```{r}
circle_lang <- langevitour::langevitour(circle, levelColors = "black", enableControls = FALSE, width = "260px", height = "170px")
```

```{r circle-proj1}
scaled_data <- scale_data_manual(circle)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

circle_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.8, 0.8), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r circle-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

circle_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.7), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r circle-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

circle_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.53), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For the one-dimensional nonlinear cycle embedded in $p\text{-}D$ space, `gen_curvycycle(n, p)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) b"} else { "Figure \\@ref(fig:sphere-proj) b"})`), let a latent angle variable $\theta$ is uniformly sampled from the interval $[0, 2\pi]$. The first three dimensions define a non-circular closed curve, referred to as a "curvy cycle". In this configuration, $X_1 = \cos(\theta)$ represents horizontal oscillation, while $X_2 = \sqrt{3}/3 + \sin(\theta)$ introduces a vertical offset to avoid centering the curve at the origin. Additionally, $X_3 = 1/3\cos(3\theta)$ introduces a third harmonic perturbation that intricately folds the curve three times along its path, creating a unique and complex shape that oscillates in both dimensions while incorporating the effects of the harmonic perturbation.

Together, these define a periodic, non-trivial, closed curve in $3\text{-}D$ with internal folds that produce a more complex geometry than a standard circle or ellipse. For dimensions $X_4$ through $X_p$, additional structured variability is introduced through decreasing amplitude scaling and phase-shifted sine waves. The scaling factor is defined as $\text{scale}_j = \sqrt{(0.5)^{j-3}}$ for $j$ ranging from $4$ to $p$, which means that the amplitude decreases as the dimension increases. Each dimension $X_j$ is then calculated using the formula $X_j = \text{scale}_j\sin(\theta + \phi_j)$, where the phase shift $\phi_j$ is given by $\phi_j = (j - 2)\pi/2p$. 

```{r data-curvycycle}
curvycycle <- gen_curvycycle(n = 1000, p = 4)
```

```{r}
curvycycle_lang <- langevitour::langevitour(curvycycle, levelColors = "black", enableControls = FALSE, width = "260px", height = "170px")
```

```{r curvycycle-proj1}
scaled_data <- scale_data_manual(curvycycle)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

curvycycle_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycycle-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.04))

curvycycle_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycycle-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.016))

curvycycle_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Building on simple circular structures, the `gen_unifsphere(n, r)` function function extends the idea to three dimensions by generating $n$ observations approximately uniformly distributed on the surface of a sphere of radius $r$.. Each observation is computed from spherical coordinates, with $u \sim U(-1, 1)$ representing $\cos(\phi)$ and $\theta \sim U(0, 2\pi)$ the azimuthal angle. Cartesian coordinates are then defined as $$X_1 = r\sqrt{1 - u^2}\cos(\theta), \quad X_2 = r\sqrt{1 - u^2}\sin(\theta),\text{ and }X_3 = ru,$$ ensuring uniform distribution on the surface (not within) of the sphere. 

```{r data-unifsphere}
unifsphere <- gen_unifsphere(n = 1000, r = 1)
```

In contrast, the `gen_hollowsphere(n, p)` function, a wrapper around `geozoo::sphere.hollow()`, generates $n$ points uniformly distributed only on the surface of the $(p-1)$-dimensional sphere embedded in $\mathbb{R}^p$. This results in a hollow shell-like structure with no interior points. For example, when $p=3$, `gen_unifsphere()` produces a solid ball in $3\text{-}D$ space, whereas `gen_hollowsphere()` produces only the spherical boundary. These paired structures allow controlled experiments to investigate how algorithms behave when data is concentrated throughout the full volume versus constrained to the boundary.

```{r data-hollowsphere}
hollowsphere <- gen_hollowsphere(n = 1000, p = 4)
```

In addition, the `gen_gridedsphere(n)` function constructs a $p$-dimensional dataset consisting of approximately $n$ points arranged on the surface of the unit $(p-1)$-sphere embedded in $\mathbb{R}^p$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) d"} else { "Figure \\@ref(fig:sphere-proj) d"})`). Rather than sampling points uniformly, this function creates a deterministic grid in spherical coordinates, using $(p-1)$ angular variables: the first $(p-2)$ angles are taken from $[0, \pi]$, and the final angle from $[0, 2\pi]$. The number of grid points along each angular dimension is determined by decomposing $n$ into $(p-1)$ approximately equal integer factors via `gen_nproduct(n, p - 1)`. 

Each grid point is subsequently mapped into Cartesian space via the standard hyperspherical-to-Cartesian transformation,

<!-- $$ -->
<!-- X_i = -->
<!-- \begin{cases} -->
<!-- \displaystyle \prod_{j=1}^{i-1} \sin(\theta_j) , \cos(\theta_i), & 1 \le i \le p-1, \\ -->
<!-- \displaystyle \prod_{j=1}^{p-1} \sin(\theta_j), & i = p, -->
<!-- \end{cases} -->
<!-- $$ -->

<!-- with the convention that $\prod_{j=1}^{0} \sin(\theta_j) = 1$. -->



$$
\begin{aligned}
X_1 &= \cos(\theta_1), \\
X_2 &= \sin(\theta_1)\cos(\theta_2), \\
X_3 &= \sin(\theta_1)\sin(\theta_2)\cos(\theta_3), \\
&\;\;\vdots \\
X_{p-1} &= \sin(\theta_1)\sin(\theta_2)\cdots \sin(\theta_{p-2})\cos(\theta_{p-1}), \\
X_p &= \sin(\theta_1)\sin(\theta_2)\cdots \sin(\theta_{p-2})\sin(\theta_{p-1}).
\end{aligned}
$$

The result is a deterministic grid of points lying exactly on the surface of the unit $(p-1)$-sphere, without any additional noise dimensions.

For more heterogeneous structures, the `gen_clusteredspheres(n, k, r, loc)` function generates one large sphere of radius $r_1$ and $k$ smaller spheres of radius $r_2$, each centered at a different random location (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) e"} else { "Figure \\@ref(fig:sphere-proj) e"})`). A large Uniform ball centered at the origin is created by sampling $n_1$ points uniformly on the surface of a $p\text{-}D$ sphere with a radius of $r_1$. The sampling is executed using the function `gen_unifsphere(n_1, r_1)`, which generates the desired points in the specified dimensional space. In generation of $k$ smaller Uniform balls, each sphere contains $n_2$ points that are sampled uniformly on a sphere with a radius of $r_2$. These spheres are positioned at distinct random locations in $p$-space, with the center of each sphere being drawn from a normal distribution $N(0, \texttt{loc}^2 I_p)$. Points on spheres are generated using the standard hyperspherical method, which involves sampling $u \sim U(-1, 1)$ to determine the cosine of the polar angle, and sampling $\theta \sim U(0, 2\pi)$ to determine the azimuthal angle (for $3\text{-}D$). Each observation is classified by cluster, with labels such as "big" for the large central sphere and "small_1" to "small_k" for the smaller spheres.

```{r data-clusteredspheres}
clusteredspheres <- gen_clusteredspheres(n = c(1000, 100), k = 3, r = c(15, 3),
                                         loc = 10 / sqrt(3)) |>
  dplyr::select(-cluster)
```

```{r}
clusteredspheres_lang <- langevitour::langevitour(clusteredspheres, levelColors = "black", enableControls = FALSE, width = "260px", height = "170px")
```

```{r clusteredspheres-proj1}
scaled_data <- scale_data_manual(clusteredspheres)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097),
  c(0.00896,0.52496,0.12597))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

clusteredspheres_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r clusteredspheres-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278),
  c(-0.50493,0.14388,0.14615))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

clusteredspheres_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.7), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r clusteredspheres-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416),
  c(0.50329,0.07199,-0.16064))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.016))

clusteredspheres_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.62), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Finally, the `gen_hemisphere(n, p)` function restricts sampling to a hemisphere of a $4\text{-}D$ sphere (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:sphere) f"} else { "Figure \\@ref(fig:sphere-proj) f"})`). Using spherical coordinates, the azimuthal angle $\theta_1 \sim U(0, \pi)$ in the $(x_1, x_2)$ plane, while the elevation angle $\theta_2 \sim U(0, \pi)$ in the $(x_2, x_3)$ plane. Additionally, $\theta_3 \sim U(0, \pi/2)$ in the $(x_3, x_4)$ plane, ensuring that the points remain restricted to a hemisphere. The coordinates are transformed into $4\text{-}D$ Cartesian space: $$X_1 = \sin(\theta_1)\cos(\theta_2), \quad X_2 = \sin(\theta_1)\sin(\theta_2), \\\quad X_3 = \cos(\theta_1)\cos(\theta_3), \quad X_4 = \cos(\theta_1)\sin(\theta_3).$$ This produces points on one side of a $4\text{-}D$ unit sphere, effectively generating a $4\text{-}D$ hemisphere. 

```{r sphere, eval=knitr::is_html_output(), fig.cap="Viewing the $4\\text{-}D$ `circle`, `curvycycle` data, and $3\\text{-}D$ `clusteredspheres` data. The `circle` structure forms a smooth, closed loop, while `curvycycle` shows a wavy, continuous pattern forming a twisted ring. The `clusteredspheres` dataset displays multiple compact spherical groups that are clearly separated in higher dimensions but overlap slightly in some $2\\text{-}D$ projections, highlighting how projection can distort spatial relationships.", fig.alt="Interactive langevitour of three datasets: circle and curvycycle in $4\\text{-}D$ showing closed-loop and wavy twisted-ring structures, and clusteredspheres in 3-D showing multiple compact spherical clusters with slight overlap in projections.", fig.pos="!ht", layout="l-body"}

spherefig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;",
    circle_lang, curvycycle_lang, clusteredspheres_lang),
  #widths=c(3,3,3),
  device = "xs"
)

class(spherefig) <- c(class(spherefig), "htmlwidget")

spherefig
```

```{r sphere-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, \\texttt{circle} (a1-a3), \\texttt{curvycycle} (b1-b3), and, $3\\text{-}D$ \\texttt{clusteredspheres} (c1-c3). The \\texttt{circle} structure forms a smooth, closed loop, while \\texttt{curvycycle} shows a wavy, continuous pattern forming a twisted ring. The \\texttt{clusteredspheres} dataset displays multiple compact spherical groups that are clearly separated in higher dimensions but overlap slightly in some $2\\text{-}D$ projections, highlighting how projection can distort spatial relationships. These projections show how simple cyclic, wavy curvilinear, and clustered structures appear in $2\\text{-}D$, emphasizing the effects of projection on density, continuity, and separation", fig.width=12, fig.height=12, out.width="80%", fig.align='center', fig.pos="H", fig.alt="Three $2\\text{-}D$ projections from each of three datasets: circle, curvycycle, and clusteredspheres, showing closed loops, twisted rings, and compact spherical clusters, illustrating projection effects on structure, density, and separation.", fig.pos="!ht"}

circle_proj1 + circle_proj2 + circle_proj3 +
curvycycle_proj1 + curvycycle_proj2 + curvycycle_proj3  +
clusteredspheres_proj1 + clusteredspheres_proj2 + clusteredspheres_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

### Swiss Roll 

The Swiss roll is a plane curled into $3\text{-}D$, and is a commonly used example of a nonlinear manifold. The `gen_swissroll(n, w)` generates points as $X_1 = t \cos(t), \quad X_2 = t \sin(t), \quad X_3 \sim U(w_1, w_2), \quad t \sim U(0, 3\pi).$

```{r data-swissroll}
swissroll <- gen_swissroll(n = 1000, w = c(-1, 1))
```

Compared with `snedata::swiss_roll()` [@james2025], this implementation (i) samples $t$ over $[0, 3\pi]$ instead of $[1.5\pi, 4.5\pi]$, (ii) allows a flexible vertical range $w = (w_1, w_2)$ rather than fixing $z \in [0, z_{\max}]$, and (iii) returns a tibble with `x1, x2, x3` instead of adding a color variable. 

The Swiss roll is a classic benchmark for manifold learning, illustrating how a curved surface can be “unrolled” into lower dimensions. Similar spiral-like forms appear in galaxies, protein folding, and coiled materials [@dimitris2002].

### Trefoil knots

<!--https://laustep.github.io/stlahblog/posts/TorusKnot4D.html-->

The Trefoil is a closed, nontrivial one-dimensional manifold embedded in $3\text{-}D$ or $4\text{-}D$ space (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:trefoil)"} else { "Figure \\@ref(fig:trefoil-proj)"})`). The trefoil features topological complexity in the form of self-overlaps, making it a valuable test case for evaluating the ability of non-linear dimension reduction methods to preserve global structure, loops, and embeddings in high-dimensional data. 

For the $4\text{-}D$ trefoil knot [@laurent2024], the function `gen_trefoil4d(n, steps)` generates the structure on the $3$-sphere ($S^3 \subset \mathbb{R}^4$) using two angular parameters, $\theta$ and $\phi$. A band of thickness around the knot path is controlled by the `steps` argument, while the number of $\theta$ and $\phi$ values is determined by the `steps` and `n` arguments, respectively (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:trefoil) a"} else { "Figure \\@ref(fig:trefoil-proj) a"})`). The coordinates are defined as $$X_1 = \cos(\theta) \cos(\phi), \quad X_2 = \cos(\theta) \sin(\phi), \\\quad X_3 = \sin(\theta) \cos(1.5 \phi),\text{ and }X_4 = \sin(\theta) \sin(1.5 \phi),$$ where $\theta$ and $\phi$ trace the knot’s path. 

```{r data-trefoil4d}
trefoil4d <- gen_trefoil4d(n = 500, steps = 5)
```

```{r}
trefoil4d_lang <- langevitour::langevitour(trefoil4d, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r trefoil4d-proj1}
scaled_data <- scale_data_manual(trefoil4d)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

trefoil4d_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil4d-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

trefoil4d_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.65), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil4d-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

trefoil4d_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For the $3\text{-}D$ stereographic projection [@laurent2024], `gen_trefoil3d(n, steps)` maps each point $(X_1, X_2, X_3, X_4) \in \mathbb{R}^4$ to $(X_1', X_2', X_3') \in \mathbb{R}^3\text{ using }X_1' = X_1 / (1 - X_4), \quad X_2' = X_2 / (1 - X_4),\text{ and }X_3' = X_3 / (1 - X_4),$ excluding points where $X_4 = 1$ to avoid division by zero (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:trefoil) b"} else { "Figure \\@ref(fig:trefoil-proj) b"})`). 

```{r data-trefoil3d}
trefoil3d <- gen_trefoil3d(n = 500, steps = 5)
```

The trefoil knot appears in molecular biology (DNA/protein knotting), fluid dynamics (knotted vortices), and physics (topological phases), making it a useful benchmark for testing whether dimension reduction preserves global loops and topology [@witten1985; @arsuaga2002].

```{r}
trefoil3d_lang <- langevitour::langevitour(trefoil3d, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r trefoil3d-proj1}
scaled_data <- scale_data_manual(trefoil3d)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097),
  c(0.00896,0.52496,0.12597))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.6, 
                                              axis_pos_y = -0.6, 
                                              threshold = 0.022))

trefoil3d_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.75, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil3d-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278),
  c(-0.50493,0.14388,0.14615))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

trefoil3d_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.65), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil3d-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416),
  c(0.50329,0.07199,-0.16064))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.55, 
                                              axis_pos_y = -0.55, 
                                              threshold = 0.016))

trefoil3d_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.62), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r trefoil, eval=knitr::is_html_output(), fig.cap="Viewing the $4\\text{-}D$ `trefoil4d` and $3\\text{-}D$ `trefoil3d` data. The `trefoil4d` structure represents a higher-dimensional extension of the classic trefoil knot, revealing complex twisting and looping patterns that remain continuous across projections. In contrast, the `trefoil3d` dataset maintains a simpler, more compact knot-like form, showing how dimensional extension adds curvature and separation in the embedded space.", fig.alt="Interactive langevitour of two trefoil knot datasets: trefoil4d in $4\\text{-}D$ showing complex twisting and looping patterns, and trefoil3d in 3-D showing a simpler compact knot-like form.", fig.pos="!ht"}

trefoilfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;",
    trefoil4d_lang, trefoil3d_lang
  ),
  device = "xs"
)

class(trefoilfig) <- c(class(trefoilfig), "htmlwidget")

trefoilfig
```

```{r trefoil-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, \\texttt{trefoil4d} (a1-a3) and $3\\text{-}D$ \\texttt{trefoil3d} (b1-b3) data. The \\texttt{trefoil4d} structure represents a higher-dimensional extension of the classic trefoil knot, revealing complex twisting and looping patterns that remain continuous across projections. In contrast, the \\texttt{trefoil3d} dataset maintains a simpler, more compact knot-like form, showing how dimensional extension adds curvature and separation in the embedded space. These projections illustrate a range of looping structures in high-dimensions.", fig.width=12, fig.height=8, fig.pos="H", out.width="80%", fig.align='center', fig.alt="Three $2\\text{-}D$ projections from each of two trefoil knot datasets, showing complex $4\\text{-}D$ trefoil loops and simpler 3-D knot structures, illustrating curvature, twisting, and separation across dimensions.", fig.pos="!ht"}

trefoil4d_proj1 + trefoil4d_proj2 + trefoil4d_proj3 + 
  trefoil3d_proj1 + trefoil3d_proj2 + trefoil3d_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

### Trigonometric

Trigonometric-based structures provide flexible ways to simulate complex curved patterns and spirals that often arise in real-world high-dimensional data, such as in biological trajectories, or physical systems (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric)"} else { "Figure \\@ref(fig:triginometric-proj)"})`). The main geometry is defined by the first few coordinates: crescents ($p=2$), cylinders, spirals, and helices ($p=4$). These structures are particularly valuable for testing how well dimension reduction and clustering algorithms preserve intricate geometric and topological features [@calladine1997; @gershenfeld2000]. 

First, the `gen_crescent(n, p)` function generates a $p$-dimensional dataset of $n$ observations based on a $2\text{-}D$ crescent-shaped manifold with optional structured high-dimensional noise (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) a"} else { "Figure \\@ref(fig:triginometric-proj) a"})`). Let $\theta \in [\pi/6, 2\pi]$ be a sequence of $n$ evenly spaced angles. The corresponding $2\text{-}D$ coordinates are defined by: $$X_1 = \cos(\theta), \quad X_2 = \sin(\theta).$$

```{r data-crescent}
crescent <- gen_crescent(n = 1000)
```

Second, the `gen_curvycylinder(n, p, h)` function generates a $p$-dimensional dataset of $n$ observations structured as a $3\text{-}D$ cylindrical manifold with an added nonlinear curvy dimension, and optional noise dimensions when $p > 4$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) b"} else { "Figure \\@ref(fig:triginometric-proj) b"})`). The core structure consists of a circular base and height values, extended by a nonlinear fourth dimension. Let $\theta \sim U(0, 3\pi)$ represent a random angle on a circular base and $z \sim U(0, h)$ represent the height along the cylinder. The coordinates are defined as: $X_1 = \cos(\theta)$ (Circular base, x-axis), $X_2 = \sin(\theta)$ (Circular base, y-axis), $X_3 = z$ (Linear height), and $X_4 = \sin(z)$ (Nonlinear curvy variation along height).  

```{r data-curvycylinder}
curvycylinder <- gen_curvycylinder(n = 1000, h = 10)
```

```{r}
curvycylinder_lang <- langevitour::langevitour(curvycylinder, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r curvycylinder-proj1}
scaled_data <- scale_data_manual(curvycylinder)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

curvycylinder_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.5), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycylinder-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

curvycylinder_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r curvycylinder-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

curvycylinder_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.5), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For a spiraling path on a spherical surface in the first four dimensions, `gen_sphericalspiral(n, p, spins)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) c"} else { "Figure \\@ref(fig:triginometric-proj) c"})`), let $\theta \in [0, 2\pi \times \text{spins}]$ be the azimuthal angle (longitude), controls the number of spiral turns and the $\phi \in [0, \pi]$be the polar angle (latitude), controls the vertical sweep from the north to the south pole. Cartesian coordinates from spherical conversion: $X_1 = \sin(\phi)\cos(\theta)$, $X_2 = \sin(\phi)\sin(\theta)$, $X_3 = \cos(\phi) + \varepsilon$, where $\varepsilon \sim U(-0.5, 0.5)$ introduces vertical jitter, and $X_4 = \theta / \max(\theta)$: a normalized progression along the spiral path. This generates a spherical spiral curve embedded in $4\text{-}D$ space, combining both circular and vertical movement, with gentle curvature and non-linear progression.  

```{r data-sphericalspiral}
sphericalspiral <- gen_sphericalspiral(n = 1000, spins = 1)
```

```{r}
sphericalspiral_lang <- langevitour::langevitour(sphericalspiral, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r sphericalspiral-proj1}
scaled_data <- scale_data_manual(sphericalspiral)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

sphericalspiral_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "b1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r sphericalspiral-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.57, 
                                              axis_pos_y = -0.57, 
                                              threshold = 0.01))

sphericalspiral_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.7, 0.6), 
  title = "b2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r sphericalspiral-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.4, 
                                              axis_pos_y = -0.4, 
                                              threshold = 0.016))

sphericalspiral_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.5, 0.5), 
  title = "b3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

For a helical spiral in four dimensions, `gen_helicalspiral(n, p)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) d"} else { "Figure \\@ref(fig:triginometric-proj) d"})`), let $\theta \in [0, 5\pi/4]$ be a sequence of angles controlling rotation around a circle. Cartesian coordinates; $X_1 = \cos(\theta)$: circular trajectory along the x-axis, $X_2 = \sin(\theta)$: circular trajectory along the y-axis, $X_3 = 0.05\theta + \varepsilon_3$, with $\varepsilon_3 \sim U(-0.5, 0.5)$: linear progression (height) with vertical jitter, simulating a helix, and $X_4 = 0.1\sin(\theta)$: oscillates with $\theta$, representing a periodic "wobble" along the fourth dimension. 

```{r data-helicalspiral}
helicalspiral <- gen_helicalspiral(n = 1000)
```

Similarly, the `gen_conicspiral(n, p, spins)` function generates a dataset of $n$ points forming a conical spiral in the first four dimensions of $p\text{-}D$ (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) e"} else { "Figure \\@ref(fig:triginometric-proj) e"})`). The geometry combines radial expansion, vertical elevation, and spiral deformation, simulating a structure that fans out like a $3\text{-}D$ conic helix. The shape is defined by parameter $\theta \in [0, 2\pi\text{spins}]$, controlling the angular progression of the spiral. The Archimedean spiral in the horizontal plane is represented by; $X_1 = \theta\cos(\theta)$ for radial expansion in x, and $X_2 = \theta\sin(\theta)$ for radial expansion in y. The growth pattern resembles a cone, with the height increasing according to $X_3 = 2\theta / \max(\theta) + \varepsilon_3$, with $\varepsilon_3 \sim U(-0.1, 0.6).$ Spiral modulation in the fourth dimension is represented by $X_4 = \theta\sin(2\theta) + \varepsilon_4$, with $\varepsilon_4 \sim U(-0.1, 0.6)$ which simulates a twisting helical component in a non-radial dimension. 

```{r data-conicspiral}
conicspiral <- gen_conicspiral(n = 1000, spins = 1)
```

```{r}
conicspiral_lang <- langevitour::langevitour(conicspiral, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r conicspiral-proj1}
scaled_data <- scale_data_manual(conicspiral)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.022))

conicspiral_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.65, 0.7), 
  title = "c1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r conicspiral-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 3, 
                                              axis_pos_x = -0.65, 
                                              axis_pos_y = -0.65, 
                                              threshold = 0.01))

conicspiral_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.8, 0.5), 
  title = "c2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r conicspiral-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.6,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.45, 
                                              axis_pos_y = -0.45, 
                                              threshold = 0.016))

conicspiral_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.62), 
  title = "c3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

Finally, the `gen_nonlinear(n, p, hc, non_fac)` function simulates a non-linear $2\text{-}D$ surface embedded in higher dimensions, constructed using inverse and trigonometric transformations applied to independent variables (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:triginometric) f"} else { "Figure \\@ref(fig:triginometric-proj) f"})`). The $X_{1} \sim U(0.1, 2)$: base variable (avoids zero to prevent division errors), $X_{3} \sim U(0.1, 0.8)$: independent auxiliary variable, $X_{2} = hc/X_{1} + \text{nonfac}\sin(X_{1})$: non-linear combination of hyperbolic and sinusoidal transformations, creating sharp curvature and oscillation, and $X_{4} = \cos(\pi X_{1}) + \varepsilon$, with $\varepsilon \sim U(-0.1, 0.1)$: additional nonlinear variation based on cosine, simulating more subtle periodic structure. These transformations together result in a non-linear surface warped in multiple ways: sharp vertical shifts due to inverse terms, smooth waves from sine and cosine, and additional jitter. 

```{r data-nonlinear}
nonlinear <- gen_nonlinear(n = 1000, hc = 1, non_fac = 0.5)
```

```{r}
nonlinear_lang <- langevitour::langevitour(nonlinear, levelColors = "black", enableControls = FALSE, width = "400px", height = "300px")
```

```{r nonlinear-proj1}
scaled_data <- scale_data_manual(nonlinear)

## First projection
projection <- cbind(
  c(0.53506,0.00763,0.00097,-0.10901),
  c(0.00896,0.52496,0.12597,0.08184))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.7,
                                              axis_scaled = 1.2, 
                                              axis_pos_x = -0.3, 
                                              axis_pos_y = -0.3, 
                                              threshold = 0.022))

nonlinear_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.45, 0.73), 
  title = "d1", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r nonlinear-proj2}

## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.45,
                                              axis_scaled = 1.3, 
                                              axis_pos_x = -0.2, 
                                              axis_pos_y = -0.2, 
                                              threshold = 0.03))

nonlinear_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.3, 0.46), 
  title = "d2", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r nonlinear-proj3}

## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.2, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 0.45,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.25, 
                                              axis_pos_y = -0.25, 
                                              threshold = 0.016))

nonlinear_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.35, 0.4), 
  title = "d3", 
  cex = 2, 
  axis_text_size = 5,
  is_color = FALSE)

```

```{r triginometric, eval=knitr::is_html_output(), fig.cap="Viewing the $4\\text{-}D$ `crescent`, `curvycylinder`, `sphericalspiral`, `helicalspiral`, `conicspiral`, and `nonlinear` data. The `curvycylinder` shows a cylindrical manifold with a nonlinear twist along its height, producing smooth, continuous curvature. The `sphericalspiral` forms a spiral path on a spherical surface, combining circular and vertical motion in a helical form. The `conicspiral` spreads radially while ascending, forming a conical helix with twisting variations in a non-radial dimension. The `nonlinear` dataset exhibits a warped $2\\text{-}D$ surface with sharp oscillations and smooth waves, reflecting complex nonlinear interactions.", fig.alt="Interactive langevitour of six datasets in $4\\text{-}D$: crescent, curvycylinder, sphericalspiral, helicalspiral, conicspiral, and nonlinear, showing cylindrical twists, spiral paths, conical helices, and warped $2\\text{-}D$ surfaces with smooth and sharp variations.", fig.pos="!ht"}

triginometricfig <- bscols(
  htmltools::div(
    style = "display: grid; grid-template-columns: 1fr 1fr;
    gap: 0px;
    align-items: start;
    justify-items: center;
    margin: 0;
    padding: 0;",
    curvycylinder_lang, sphericalspiral_lang, conicspiral_lang, nonlinear_lang
  ),
  device = "xs"
)

class(triginometricfig) <- c(class(triginometricfig), "htmlwidget")

triginometricfig
```

```{r triginometric-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the \\texttt{curvycylinder} (a1-a3), \\texttt{sphericalspiral} (b1-b3), \\texttt{conicspiral} (c1-c3), and \\texttt{nonlinear} (d1-d3) data. The \\texttt{curvycylinder} shows a cylindrical manifold with a nonlinear twist along its height, producing smooth, continuous curvature. The \\texttt{sphericalspiral} forms a spiral path on a spherical surface, combining circular and vertical motion in a helical form. The \\texttt{conicspiral} spreads radially while ascending, forming a conical helix with twisting variations in a non-radial dimension. The \\texttt{nonlinear} dataset exhibits a warped $2\\text{-}D$ surface with sharp oscillations and smooth waves, reflecting complex nonlinear interactions. Each shows variations in curvature, density, and continuity.", fig.width=12, fig.height=16, out.width="70%", fig.align='center', fig.pos="H", fig.alt="Three $2\\text{-}D$ projections from each of four $4\\text{-}D$ datasets: curvycylinder, sphericalspiral, conicspiral, and nonlinear, showing cylindrical twists, spiral and conical helices, and warped $2\\text{-}D$ surfaces, illustrating curvature, density, and continuity.", fig.pos="!ht"}

curvycylinder_proj1 + curvycylinder_proj2 + curvycylinder_proj3 +
sphericalspiral_proj1 + sphericalspiral_proj2 + sphericalspiral_proj3 +
conicspiral_proj1 + conicspiral_proj2 + conicspiral_proj3 +
nonlinear_proj1 + nonlinear_proj2 + nonlinear_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```

## Generate a spherical or hyperspherical hole within a structure

The package provides functionality for generating datasets with spherical hole (in $2\text{-}D$/$3\text{-}D$) or, more generally, hyperspherical hole (in higher dimensions). These structures are valuable for evaluating how dimension reduction methods and clustering algorithms handle incomplete manifolds or missing regions of the data space. A hyperspherical hole introduces topological complexity: the structure remains continuous but contains excluded regions (voids) that algorithms must correctly represent in lower-dimensional embeddings.

The core function `gen_hole(df, anchor, r)` removes points from a dataset that fall within a user-specified hypersphere. Formally, given data points ($x \in \mathbb{R}^p$), a center ($a \in \mathbb{R}^p$), and radius ($r > 0$), only points satisfying $\sqrt{\sum_{i=1}^n(x_i-a_i)^2} > r$ are retained. The anchor point ($a$) can either be user-specified or default to the dataset mean, and radius ($r$) is controlled by the user, with safeguards to avoid trivial or degenerate cases. Because it operates generically on any dataset, spherical or hyperspherical holes can be embedded in a wide range of geometric structures.

Two specialized wrappers illustrate this idea. The function `gen_scurvehole(n, r_hole)` generates an S-curve with a spherical hole by applying `gen_hole()` to the output of `gen_scurve()`. This structure has been used in prior diagnostic studies of NLDR methods [@tenenbaum2000, @van2007], since it tests the ability of algorithms to capture non-linear manifolds that are not simply connected. The second wrapper, `gen_unifcubehole(n, p, r_hole)`, generates uniformly sampled cube data with a hyperspherical hole. By embedding a hyperspherical void inside a convex high-dimensional structure, this creates non-convex regions that challenge algorithms in terms of separability and neighborhood preservation.

## Generate noise dimensions

High-dimensional data structures often benefit from the addition of auxiliary noise dimensions, which can be used to assess the robustness of dimensionality reduction and clustering algorithms. The functions in this section provide flexible ways to generate random noise dimensions, ranging from purely random Gaussian variables to more structured, wavy patterns that mimic non-linear distortions in high-dimensional space. These functions can be applied independently or combined with other geometric structures to create complex simulated datasets. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:noise-tb-html)', '\\@ref(tab:noise-tb-pdf)'))` details these functions.

```{r}
noise_fun_tb <- tibble(fun = c("gen_noisedims",
                            "gen_wavydims1",
                            "gen_wavydims2",
                            "gen_wavydims3"), 
                        exp = c("Gaussian noise dimensions with optional mean and standard deviation.",
                                "Wavy noise dimensions based on a user-specified theta sequence with added jitter.",
                                "Wavy noise dimensions using polynomial transformations of an existing dimension vector.",
                                "Wavy noise dimensions using a combination of polynomial and sine transformations based on the first three dimensions of a dataset.")) |> 
  mutate(fun = gsub("_", "\\\\_", fun))
```

```{r noise-tb-html, eval=knitr::is_html_output()}
noise_fun_tb |> 
  mutate(fun = paste0("<code>", fun, "</code>")) |> 
  kable(caption = "cardinalR noise dimensions generation functions", col.names = c("Function", "Explanation"), escape = FALSE, table.pos = "!ht") 
```

```{r noise-tb-pdf, eval=knitr::is_latex_output()}
noise_fun_tb |> 
  mutate(fun = paste0("\\texttt{", fun, "}")) |> 
  kable(caption = "cardinalR noise dimensions generation functions", format="latex", col.names = c("Function", "Explanation"), escape = FALSE, booktabs = T, table.pos = "!ht")  |>
  column_spec(1, width = "2.5cm") |>
  column_spec(2, width = "10.5cm")
```

The `gen_noisedims(n, p, m, s)` function generates $p$ independent Gaussian noise dimensions,

$$
X_j \sim N(m_j, s_j^2), \quad j = 1, \dots, p,
$$

with odd-numbered dimensions multiplied by $-1$. This does not affect independence, since all noise dimensions are generated independently. The sign alternation is included only to avoid consistent directional drift and to ensure a symmetric appearance of noise when visualized or combined with other simulated structures.

For scenarios where noise should follow a smooth wavy pattern, `gen_wavydims1(n, p, theta)` generates dimensions as

$$
X_j = \alpha_j \theta + \varepsilon_j, \quad \varepsilon_j \sim N(0, \sigma^2), \quad j = 1, \dots, p,
$$

where each dimension is scaled by a different factor $\alpha_j$, producing structured noise that oscillates along the latent parameter $\theta$, mimicking trends or trajectories observed in real-world data.

The `gen_wavydims2(n, p, x_1)` function extends this approach by applying a non-linear transformation to an existing dimension vector $x_1$:

$$
X_j = \beta_j \, (-1)^{\lfloor j/2 \rfloor} \, x_1^{k_j} + \varepsilon_j, \quad j = 1, \dots, p,
$$

where $k_j$ is a randomly chosen polynomial power, $\beta_j$ is a scaling factor, and $\varepsilon_j$ is small uniform noise.

Finally, `gen_wavydims3(n, p, data)` generates noise for datasets with multiple correlated dimensions. The first three dimensions are small perturbations of the original coordinates $(X_1, X_2, X_3)$, while higher dimensions are constructed via non-linear combinations, including polynomial and trigonometric transformations, e.g.,

$$
X_j = f_j(X_1, X_2, X_3) + \varepsilon_j, \quad j > 3,
$$

producing high-dimensional noise that preserves some geometric correlation with the base structure while introducing additional complexity.

## Rotating shape generators

In $p\text{-}D$ space, a rotation is an orthogonal transformation that changes the orientation of data while preserving its total variance and pairwise distances. The function `gen_rotation()` generates such rotation matrices for any dimension, given a list of rotation planes (axis pairs) and angles.

## Multiple cluster examples

By using the shape generators mentioned above, we can create various examples of multiple clusters. The package includes some of these examples, which are described in Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:odd-shape-tb-html)', '\\@ref(tab:odd-shape-tb-pdf)'))`.

```{r}
odd_shapes_tb <- tibble(fun = c("make_mobiusgau",
                                "make_multigau",
                                "make_curvygau",
                                "make_klink_circles",
                                "make_chain_circles",
                                "make_klink_curvycycle",
                                "make_chain_curvycycle",
                                "make_gaucircles",
                                "make_gaucurvycycle",
                                "make_onegrid",
                                "make_twogrid_overlap",
                                "make_twogrid_shift",
                                "make_shape_para"), 
                        exp = c(
    "Möbius-like cluster combined with a Gaussian.",
    "Multiple Gaussian clusters in high-dimensional space.",
    "Curvilinear cluster with a Gaussian cluster.",
    "K-link circular clusters (non-linear circular patterns).",
    "Chain-like circular clusters connected sequentially.",
    "K-link curvy cycle clusters (curvilinear loop structures).",
    "Chain-like curvy cycle clusters connected sequentially.",
    "Circular clusters with a Gaussian cluster in the middle.",
    "Curvy circular clusters with a Gaussian in the middle.",
    "Single grid in two dimensions.",
    "Two overlapping grids.",
    "Two grids shifted relative to each other.",
    "Parallel shaped clusters.")) |> 
  mutate(fun = gsub("_", "\\\\_", fun))
```

```{r odd-shape-tb-html, eval=knitr::is_html_output()}
odd_shapes_tb |> 
  mutate(fun = paste0("<code>", fun, "</code>")) |> 
  kable(caption = "cardinalR multiple clusters generation functions", col.names = c("Function", "Explanation"), linesep = "", escape = FALSE, table.pos = "!ht") 
```

```{r odd-shape-tb-pdf, eval=knitr::is_latex_output()}
odd_shapes_tb |> 
  mutate(fun = paste0("\\texttt{", fun, "}")) |> 
  kable(caption = "cardinalR multiple clusters generation functions", format="latex", col.names = c("Function", "Explanation"), escape = FALSE, booktabs = T, linesep = "", table.pos = "!ht")  |>
  column_spec(1, width = "3.5cm") |>
  column_spec(2, width = "8.5cm")
```

## Additional functions

The package includes various supplementary tools in addition to the shape generating functions mentioned earlier. These tools allow users to create background noise, randomize the rows of the data, relocate clusters, generate a vector whose product and sum are approximately equal to a target value, rotate structures, and normalize the data. Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:add-tb-html)', '\\@ref(tab:add-tb-pdf)'))` details these functions. More detailed explanations are available in [jayanilakshika.github.io/cardinalR/articles/03additionalfun](https://jayanilakshika.github.io/cardinalR/articles/03additionalfun.html).

```{r}
add_fun_tb <- tibble(fun = c("gen_bkgnoise",
                            "randomize_rows",
                            "relocate_clusters",
                            "gen_nproduct",
                            "gen_nsum",
                            "normalize_data"), 
                        exp = c("Adds background noise.",
                                "Randomizes the rows of input data.",
                                "Relocates the clusters.",
                                "Generates a vector of positive integers whose product is approximately equal to a target value.",
                                "Generates a vector of positive integers whose summation is approximately equal to a target value.", 
                                "Normalizes data.")) |> 
  mutate(fun = gsub("_", "\\\\_", fun))
```

```{r add-tb-html, eval=knitr::is_html_output()}
add_fun_tb |> 
  mutate(fun = paste0("<code>", fun, "</code>")) |> 
  kable(caption = "cardinalR additional functions", col.names = c("Function", "Explanation"), linesep = "", escape = FALSE, table.pos = "!ht") 
```

```{r add-tb-pdf, eval=knitr::is_latex_output()}
add_fun_tb |> 
  mutate(fun = paste0("\\texttt{", fun, "}")) |> 
  kable(caption = "cardinalR additional functions", format="latex", col.names = c("Function", "Explanation"), booktabs = T, linesep = "", escape = FALSE, table.pos = "!ht")  |>
  column_spec(1, width = "4cm") |>
  column_spec(2, width = "8cm")
```

# Application

This section demonstrates how the package can be used to generate complex high-dimensional datasets, evaluate dimension reduction (DR) and clustering methods. The example shows how diverse geometric structures can be simulated and analyzed to assess algorithmic behavior.

To illustrate how high-dimensional clustered data can be generated using `cardinalR`, we generate a dataset with five clusters in $4\text{-}D$, each representing distinct geometric characteristics: a *helical spiral* (elongated and twisted), a *hemisphere* (curved surface), a *uniform cube* (isotropic distribution), a *cone* (density gradient), and a *Gaussian* cluster (compact and spherical) (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:highd-data)"} else { "Figure \\@ref(fig:highd-proj)"})`). Each cluster has a unique number of points and scaling factor, representing variation in cluster size and spread across the $4\text{-}D$ space.

```{r gen-five-clust-data, echo=TRUE}

positions <- geozoo::simplex(p=4)$points
positions <- positions * 0.3

five_clusts <- gen_multicluster(n = c(2250, 1500, 750, 1250, 1750), k = 5,
                       loc = positions,
                       scale = c(0.25, 0.35, 0.3, 1, 0.3),
                       shape = c("helicalspiral", "hemisphere", "unifcube", 
                                 "cone", "gaussian"),
                       rotation = NULL,
                       is_bkg = FALSE)
```

```{r highd-data, eval=knitr::is_html_output(), fig.cap="Viewing five synthetic clusters with distinct geometric structures: a helical spiral, a hemisphere, a uniform cube, a cone, and a Gaussian cluster.", fig.alt="Interactive langevitour of five synthetic clusters in $4\\text{-}D$: helical spiral, hemisphere, uniform cube, cone, and Gaussian cluster, each colored distinctly to highlight geometric structure.", fig.pos="!ht"}

langevitour::langevitour(five_clusts[, -5], group = five_clusts$cluster, levelColors = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e'))
```

```{r five-clusts-projections1}
scaled_data <- scale_data_manual(five_clusts[, -5])

## First projection
projection <- cbind(
  c(-0.59692,0.46414,0.42436,-0.10048),
  c(-0.54999,-0.67673,-0.03631,-0.01193))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj1[["cluster"]] <- as.character(five_clusts$cluster)

five_clusts_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")

```

```{r five-clusts-projections2}
## Second projection
projection <- cbind(
  c(0.34673,-0.35774,0.66272,0.27298),
  c(0.24023,0.01170,-0.41886,0.72707))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.07))

proj_obj2[["cluster"]] <- as.character(five_clusts$cluster)

five_clusts_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.2), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")
```

```{r five-clusts-projections3}
## Third projection
projection <- cbind(
  c(0.47388,-0.20984,-0.56560,0.41644),
  c(-0.51124,-0.60184,0.06463,0.36627))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj3[["cluster"]] <- as.character(five_clusts$cluster)

five_clusts_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.1), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")

```

```{r highd-proj, eval=knitr::is_latex_output(), fig.pos="!ht", fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the five clusters data. The helical spiral cluster is represented in dark green, the hemisphere cluster in orange, the uniform cube-shaped cluster in purple, the blunted cone cluster in pink, and the Gaussian-shaped cluster in light green.", fig.alt="Three $2\\text{-}D$ projections of five $4\\text{-}D$ synthetic clusters: helical spiral (dark green), hemisphere (orange), uniform cube (purple), cone (pink), and Gaussian (light green), showing spatial separation and cluster geometry.", fig.width=12, fig.height=4, fig.pos="!ht"}

five_clusts_proj1 + five_clusts_proj2 + five_clusts_proj3 +
  plot_layout(ncol = 3) 
```

## Evaluating dimension reduction (DR) methods

We applied six popular DR techniques to the generated dataset: Principal Component Analysis (PCA) [@jolliffe2011], tSNE, uniform manifold approximation and projection (UMAP) [@leland2018], potential of heat-diffusion for affinity-based trajectory embedding (PHATE) algorithm [@moon2019], large-scale dimensionality reduction Using triplets (TriMAP) [@amid2019], and pairwise controlled manifold approximation (PaCMAP) [@yingfan2021]. 

<!--scripts/five_clusts/02_gen_embeddings.R-->
```{r layouts}

tsne_data <- read_rds("data/five_clusts/five_clusts_tsne_perplexity_30.rds") 

nldr1 <- tsne_data |>
  ggplot(aes(x = tSNE1,
             y = tSNE2))+
  geom_point(alpha=0.1, size=1, colour = '#636363') +
  interior_annotation("a", c(0.08, 0.93)) + 
  theme(aspect.ratio = 1) 

umap_data <- read_rds("data/five_clusts/five_clusts_umap_n-neigbors_15_min-dist_0.1.rds") 

nldr2 <- umap_data |>
  ggplot(aes(x = UMAP1,
             y = UMAP2))+
  geom_point(alpha=0.1, size=1, colour = '#d95f02') +
  interior_annotation("b", c(0.08, 0.93)) + 
  theme(aspect.ratio = 1) 

phate_data <- read_rds("data/five_clusts/five_clusts_phate_knn_5.rds") 

nldr3 <- phate_data |>
  ggplot(aes(x = PHATE1,
             y = PHATE2))+
  geom_point(alpha=0.1, size=1, colour = '#7570b3') +
  interior_annotation("c", c(0.08, 0.93)) + 
  theme(aspect.ratio = 1) 

trimap_data <- read_rds("data/five_clusts/five_clusts_trimap_n-inliers_12_n-outliers_4_n-random_3.rds") 

nldr4 <- trimap_data |>
  ggplot(aes(x = TriMAP1,
             y = TriMAP2))+
  geom_point(alpha=0.1, size=1, colour = '#e7298a') +
  interior_annotation("d", c(0.08, 0.93)) + 
  theme(aspect.ratio = 1) 

pacmap_data <- read_rds("data/five_clusts/five_clusts_pacmap_n-neighbors_10_init_random_MN-ratio_0.5_FP-ratio_2.rds") 

nldr5 <- pacmap_data |>
  ggplot(aes(x = PaCMAP1,
             y = PaCMAP2))+
  geom_point(alpha=0.1, size=1, colour = '#66a61e') +
  interior_annotation("e", c(0.08, 0.93)) + 
  theme(aspect.ratio = 1) 

pca_data <- read_rds("data/five_clusts/five_clusts_pca.rds") 

nldr6 <- pca_data |>
  ggplot(aes(x = pca1,
             y = pca2))+
  geom_point(alpha=0.1, size=1, colour = '#a6761d') +
  interior_annotation("f", c(0.08, 0.93)) + 
  theme(aspect.ratio = 1) 
```

<!--scripts/five_clusts/03_gen_rmse.R-->
```{r}
error_five_clust <- read_rds("data/five_clusts/five_clusts_hbe.rds")

error_five_clust <- error_five_clust |>
  mutate(a1 = round(a1, 2)) |>
  filter(b1 >= 5) |>
  group_by(method, a1) |>
  filter(HBE == min(HBE)) |>
  ungroup()

error_plot_five_clust <- plot_hbe(error_five_clust) +
  scale_x_continuous(breaks = sort(unique(error_five_clust$a1))[c(1, 5, 9, 13, 17, 21, 25)]) +
  scale_color_manual(values=c("tSNE" = '#636363', "UMAP" = '#d95f02', "PHATE" = '#7570b3', "TriMAP" = '#e7298a', "PaCMAP" = '#66a61e', "PCA" = '#a6761d'))
```

```{r, label = "fig-nldr-layouts", fig.pos="H", fig.cap="Assessing which of the 6 NLDR layouts ((a) tSNE, (b) UMAP, (c) PAHTE, (d) TriMAP, (e) PaCMAP, and (f) PCA) of the five clusters data is the better representation using HBE for varying binwidth ($a_1$). Colour is used for the lines and points in the left plot to match the scatterplots of the NLDR layouts (a-f). Layout f is universally poor. Layouts a and b are universally optimal. Layout b shows six well-separated clusters and layout a shows close clusters, thus layout a is the best choice.", fig.alt="Composite plot assessing six NLDR layouts of five clusters data using HBE over varying binwidths, showing tSNE, UMAP, PAHTE, TriMAP, PaCMAP, and PCA. Layouts a and b are optimal, f is poor, with color-coded lines matching the scatterplots of each layout.", fig.pos="!ht"}

error_plot_five_clust + wrap_plots(nldr1, nldr2, nldr3, 
                                    nldr4, nldr5, nldr6, ncol = 2)
```

To assess their performance, we computed the hexbin error (HBE) between the observed high-dimensional data and the fitted values, defined as the high-dimensional mappings of the bin centroids [@gamage2025c]. A lower HBE indicates that the method better preserves the high-dimensional structure in its low-dimensional embedding.

As shown in Figure \@ref(fig:fig-nldr-layouts), tSNE (Figure \@ref(fig:fig-nldr-layouts) a) achieved the lowest HBE across bin widths (mostly tiny), indicating high preservation of both local and global structures. Its layout displays well-separated clusters with minimal inter-cluster distances, making it the most faithful representation of the underlying data structure. UMAP and PaCMAP (Figure \@ref(fig:fig-nldr-layouts) b and e) produced moderately accurate embeddings, although the six clusters appear more well-separated, while PHATE (Figure \@ref(fig:fig-nldr-layouts) c) show non-linear cluster structures irrespective of the original structure. Also, TriMAP (Figure \@ref(fig:fig-nldr-layouts) d) has high HBE, and show three clusters with small distances. PCA (Figure \@ref(fig:fig-nldr-layouts) f) failed to capture the non-linear geometry, leading to the highest HBE.

## Benchmarking clustering algorithms

To further evaluate the structure of the generated data, we benchmarked three clustering algorithms: **$k$-means** [Chapter 20 of @boehmke2019], **hierarchical** [@murtagh2012], and **model-based clustering** [@chris2002; @scrucca2023] using the simulated dataset. Model-based clustering performed the `"EII"` covariance structure. Under this parameterization, clusters are spherical with equal volume and equal shape, and no orientation parameter is estimated. Cluster validity statistics were computed using the `cluster.stats()` function from the `fpc` package [@christian2024].

<!--script/05_gen_cluster_stat.R-->
```{r, label = "fig-cluster-stats", fig.width=10, fig.height=3, out.width="100%", layout="l-body", fig.cap="Cluster validity metrics for solutions with $2–10$ clusters obtained using $k$-means, hierarchical, and model-based clustering. Several indices consistently suggest that $4–5$ clusters provide the best balance of separation and compactness, with $k$-means performing slightly better across metrics."}

# Examine the cluster stats
all_stats <- read_rds("data/five_clusts/cluster_stat.rds")
all_stats |>
  pivot_longer(within.cluster.ss:sindex, names_to = "stat", values_to = "value") |>
  ggplot(aes(x=cl, y=value, colour=method)) +
    geom_line() +
    facet_wrap(~stat, ncol=3, scales="free_y") +
    xlab("Number of clusters") +
    ylab("") +
    scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3')) +
    theme_minimal() +
    theme(panel.border = element_rect(fill = 'transparent'),
          plot.title = element_text(size = 12, hjust = 0.5, vjust = -0.5),
          axis.ticks.x = element_line(),
          axis.ticks.y = element_line(),
          legend.position = "bottom",
          axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7),
          axis.title.x = element_text(size = 7),
          axis.title.y = element_text(size = 7),
          plot.margin = margin(0, 0, 0, 0))
```

Figure \@ref(fig:fig-cluster-stats) shows a selection of cluster metrics for $2-10$ clusters for each of the methods, $k$-means, hierarchical, and model-based. As is typical, the suggestion of the best solution varies between cluster statistics. Although the metrics differ in their preferences, several show consistent support for a $4-5$ cluster solution. The Calinski–Harabasz index increases sharply up to four or five clusters before levelling off, the Dunn and Pearson gamma indices attain local maxima in this range, and both the silhouette width and within-cluster sum of squares show diminishing improvement beyond five clusters. Together, these patterns indicate that $4-5$ clusters provide a good balance of separation and compactness, with $k$-means performing slightly better than the other methods across most metrics.

```{r}
## k-means with  four clusters
kcl4 <- kmeans(five_clusts[, -5], centers = 4, nstart = 20)$cluster

## k-means with  five clusters
kcl5 <- kmeans(five_clusts[, -5], centers = 5, nstart = 20)$cluster
```

```{r highd-data-clusters-algo-html, eval=knitr::is_html_output(), fig.cap="Views of the five-cluster synthetic dataset coloured by the $k$-means four- and five-cluster solutions. These show how the five true structures: helical spiral, hemisphere, uniform cube, blunted cone, and Gaussian-shaped cluster appear under $k$-means partitions. Both the $4$- and $5$-cluster solutions mix colours, revealing substantial misclassification and limited ability of $k$-means to recover the underlying geometric structure.", fig.pos="!ht", layout = "l-body"}

four_km_langevitour <- langevitour::langevitour(
  five_clusts[, -5],
  group = kcl4,
  levelColors = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e'),
  width = "350px",
  height = "300px"
)

five_km_langevitour <- langevitour::langevitour(
  five_clusts[, -5],
  group = kcl5,
  levelColors = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e'),
  width = "350px",
  height = "300px"
)

km_results <- browsable(
  div(
    style = "
      display: flex;
      justify-content: space-between;
      gap: 5px;
    ",
    div(style = "flex: 1;", four_km_langevitour),
    div(style = "flex: 1;", five_km_langevitour)
  )
)

class(km_results) <- c(class(km_results), "htmlwidget")

km_results
```

```{r five-4clusts-projections1}
scaled_data <- scale_data_manual(five_clusts[, -5])

## First projection
projection <- cbind(
  c(-0.59692,0.46414,0.42436,-0.10048),
  c(-0.54999,-0.67673,-0.03631,-0.01193))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj1[["cluster"]] <- as.character(kcl4)

five_clusts_proj1_1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")

```

```{r five-4clusts-projections2}
## Second projection
projection <- cbind(
  c(0.34673,-0.35774,0.66272,0.27298),
  c(0.24023,0.01170,-0.41886,0.72707))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.07))

proj_obj2[["cluster"]] <- as.character(kcl4)

five_clusts_proj2_1 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.2), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")
```

```{r five-4clusts-projections3}
## Third projection
projection <- cbind(
  c(0.47388,-0.20984,-0.56560,0.41644),
  c(-0.51124,-0.60184,0.06463,0.36627))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj3[["cluster"]] <- as.character(kcl4)

five_clusts_proj3_1 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.1), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")

```

```{r five-5clusts-projections1}
scaled_data <- scale_data_manual(five_clusts[, -5])

## First projection
projection <- cbind(
  c(-0.59692,0.46414,0.42436,-0.10048),
  c(-0.54999,-0.67673,-0.03631,-0.01193))

proj_obj1 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj1[["cluster"]] <- as.character(kcl5)

five_clusts_proj1_2 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")

```

```{r five-5clusts-projections2}
## Second projection
projection <- cbind(
  c(0.34673,-0.35774,0.66272,0.27298),
  c(0.24023,0.01170,-0.41886,0.72707))

proj_obj2 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.07))

proj_obj2[["cluster"]] <- as.character(kcl5)

five_clusts_proj2_2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.2), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")
```

```{r five-5clusts-projections3}
## Third projection
projection <- cbind(
  c(0.47388,-0.20984,-0.56560,0.41644),
  c(-0.51124,-0.60184,0.06463,0.36627))

proj_obj3 <- get_projection(projection = projection, 
                            proj_scale = 1.23, 
                            scaled_data = scaled_data, 
                            axis_param = list(limits = 1,
                                              axis_scaled = 0.8, 
                                              axis_pos_x = -0.9, 
                                              axis_pos_y = -0.9, 
                                              threshold = 0.05))

proj_obj3[["cluster"]] <- as.character(kcl5)

five_clusts_proj3_2 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2), # size, alpha, color
  plot_limits = c(-1.1, 1.1), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 4,
  is_color = TRUE) + scale_color_manual(values = c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e')) +
  theme(legend.position = "none")

```

```{r highd-proj-clust-algo-pdf, eval=knitr::is_latex_output(), fig.pos="!ht", fig.cap="Three $2\\text{-}D$ projections from $4\\text{-}D$, for the five clusters data coloured by the $k$-means four- (a1-a3) and five-cluster (b1-b3) solutions. The intermixing of colours within each projection reflects misclassification in both solutions, showing the difficulty of using $k$-means to capture the dataset’s nonlinear and heterogeneous shapes.", fig.width=12, fig.height=8, fig.pos="!ht"}

five_clusts_proj1_1 + five_clusts_proj2_1 + five_clusts_proj3_1 +
  five_clusts_proj1_2 + five_clusts_proj2_2 + five_clusts_proj3_2 +
  plot_layout(ncol = 3) 
```

`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:highd-data-clusters-algo-html)"} else { "Figure \\@ref(fig:highd-proj-clust-algo-pdf)"})` shows the four- and five-cluster $k$-means solutions further clarify why these partitions do not fully identify the underlying structure. The predicted clusters show noticeable overlap, with colours repeatedly blending as the tour moves; evidence that points from different true clusters are assigned to the same cluster. The $4$-cluster solution shows large, diffuse regions where several true clusters are merged, while the $5$-cluster solution partially separates some structures but still misclassifies substantial portions of multiple clusters. These patterns reflect the mismatch between the helical spherical shape present in the data and the spherical decision boundaries imposed by $k$-means. Even though the cluster statistics favour a $4-5$ cluster solution overall, `r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:highd-data-clusters-algo-html)"} else { "Figure \\@ref(fig:highd-proj-clust-algo-pdf)"})` reveals that neither solution provides clear separation, highlighting the importance of visual diagnostics when interpreting clustering results.

# Conclusion

The `cardinalR` package introduces a flexible framework for generating high-dimensional data structures with well-defined geometric properties. It addresses an important need in the evaluation of clustering, machine learning, and DR methods by enabling the construction of customized datasets with interpretable structures, noise characteristics, and clustering arrangements. In this way, `cardinalR` complements existing packages such as `geozoo`, `snedata`, and `mlbench`, while extending the scope to higher dimensions and more complex shapes.

The included structures cover a wide range of diagnostic settings. Branching shapes facilitate the study of continuity and topological preservation, the S-curve with a hole allows investigation of incomplete manifolds, and clustered spheres assess separability on curved surfaces. The Möbius strip introduces challenges from non-orientable geometry, while gridded cubes and pyrholes test spatial regularity and clustering in sparse, non-convex regions.

These structures are designed to support not only algorithm diagnostics, but also teaching high-dimensional concepts, benchmarking reproducibility, and evaluating hyper-parameter sensitivity. By allowing users to adjust dimensionality, sample size, noise, and clustering properties, the package promotes transparent experimentation and comparative model evaluation. Together, these capabilities make `cardinalR` a versatile tool for generating interpretable, high-dimensional datasets that advance research, teaching, and evaluation of data-analytic methods.

Future extensions of `cardinalR` may include biologically inspired or application-driven data structures that would further broaden its utility in domains such as bioinformatics, forensic science, and spatial analysis.

# Acknowledgements

The source material for this paper is available at [github.com/JayaniLakshika/paper-cardinalR](https://github.com/JayaniLakshika/paper-cardinalR). This article is created using \CRANpkg{knitr} [@yihui2015] and \CRANpkg{rmarkdown} [@yihui2018] in R with the `rjtools::rjournal_article` template. These `R` packages were used for this work: `cli` [@gabor2025], `tibble` [@kirill2023], `gtools` [@gregory2023], `dplyr` [@hadley2023], `stats` [@core2025], `tidyr` [@hadley2024], `purrr` [@hadley2025], `mvtnorm` [@alan2009], `geozoo` [@barret2016], and `MASS` [@venables2002]. 
