---
title: "Sample cardinalR"
author: "Chat-GPT"
date: "2025-09-10"
format: pdf
---

### Branching

A branching structure (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch)"} else { "Figure \\@ref(fig:branch-proj)"})`) captures trajectories that diverge or bifurcate from a common origin, similar to processes such as cell differentiation in biology [@trapnell2014]. We introduce a set of data generation functions specifically designed to simulate high-dimensional branching structures with various geometries, total number of points (`n`) generated across all branches, with points allocated approximately evenly among branches, and number of branches (`k`). Although these functions can generate multiple branches, they do not produce a formal *multicluster* dataset: the branches form a single connected structure, with multiple visually distinct arms rather than independent clusters. 

The simplest structures are approximately linear branches in $2\text{-}D$, generated by the `gen_linearbranches(n, k)` function. These consist of $k$ short line segments in the first two dimensions, with added jitter to simulate variability. Mathematically, each branch $i$ is defined as

$$
X_1 \sim U(a_i, b_i), \quad X_2 = s_i (X_1 - x_{\text{start},i}) + y_{\text{start},i} + \epsilon, \quad \epsilon \sim U(0, \delta),
$$

where $(x_{\text{start},i}, y_{\text{start},i})$ is the starting point of branch $i$, $\delta$ controls local jitter, and $s_i$ is the slope, initialized as

$$
s_i =
\begin{cases}
0.5 & i = 1, \\
-0.5 & i = 2, \\
\text{randomly sampled from } [s_{\min}, s_{\max}] & i = 3, \dots, k.
\end{cases}
$$

The jitter term is sampled from a one-sided uniform distribution to introduce directional variability without altering branch orientation.

Branches $1$ and $2$ are initialized with fixed slopes and starting points, while later branches are iteratively added at locations chosen to avoid overlap with existing branches, producing a set of connected linear paths. 

To introduce curvature, the `gen_curvybranches(n, k)` function generates $k$ curvilinear branches in $2\text{-}D$. Each branch follows a quadratic trajectory of the form

$$
X_1 \sim U(a_i, b_i), \quad X_2 = 0.1 X_1 + s_i X_1^2 + \epsilon, \quad \epsilon \sim U(-\delta, \delta),
$$
where $(a_i, b_i)$ defines the domain of the branch, $s_i$ controls curvature, and $\delta$ introduces local jitter. For the first two branches, the parameters are fixed to establish reference shapes: $(a_1,b_1,s_1) = (0,1,1), \quad (a_2,b_2,s_2) = (-1,0,-2)$. Additional branches are attached iteratively to existing structures. Each new branch $i$ starts at a selected point $(x_{\text{start},i}, y_{\text{start},i})$ from the current structure and extends according to

$$
X_1 \sim U(x_{\text{start},i}, x_{\text{start},i}+1), \quad X_2 = 0.1 X_1 - s_i (X_1^2 - x_{\text{start},i}) + y_{\text{start},i},
$$

where $s_i$ is a scale factor controlling the curvature of branch $i$. For the first few initial branches, $s_i$ can be fixed (e.g., $s_1 = 1, s_2 = 2$) to establish reference shapes, while for subsequent branches it is sampled from a predefined set, such as $s_i \in \{-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5\}$, to control curvature magnitude and direction. 

The `gen_expbranches(n, k)` function creates $k$ exponential branches in $2\text{-}D$, radiating from a central region. Each branch $i$ is defined as

$$
X_1 \sim U(-2,2), \quad X_2 = \exp(\sigma_i \, s_i \, X_1) + \epsilon, \quad \epsilon \sim U(0, \delta), \quad s_i \sim U(0.5,2),
$$

where $\sigma_i = (-1)^{i+1}$ alternates the sign of the exponent to produce mirror-symmetric branches. The parameter $s_i$ controls the steepness of branch $i$, and $\delta$ introduces small local jitter.

High-dimensional generalizations are provided by `gen_orglinearbranches(n, p, k)` (`r knitr::asis_output(if (knitr::is_html_output()) { "Figure \\@ref(fig:branch)"} else { "Figure \\@ref(fig:branch-proj)"})`) and `gen_orgcurvybranches(n, p, k)`. For branch 
$i$, the active coordinate pair $(i_1, i_2)$ indexes the selected $2\text{-}D$ subspace. When `allow_share = TRUE`, multiple branches may share the same subspace; otherwise, subspaces are sampled without replacement until all possible $\binom{p}{2}$ combinations are exhausted, after which additional branches may repeat subspaces. 

In both cases, branch $i$ is generated according to

$$
X_{i_1} \sim U(a_i, b_i), \quad
X_{i_2} = f_i(X_{i_1}) + \epsilon, \quad
\epsilon \sim N(0, \sigma^2),
$$
where $a_i$ and $b_i$ define the domain of the branch and $\epsilon$ introduces smooth variability in the $p\text{-}D$ space. The function $f_i(\cdot)$ determines the branch geometry:
$$
f_i(x) =
\begin{cases}
s_i x, & \text{linear branches}, \\
-s_i x^2, & \text{curvilinear branches}.
\end{cases}
$$

The scale factor $s_i$ controls slope (linear branches) or curvature (curvilinear branches) and is assigned as follows: for the first $\binom{p}{2}$ branches, $s_i = 1$; for additional branches when $k > \binom{p}{2}$, $s_i$ is randomly drawn from the set $\{1, 1.5, 2, \dots, 8\}$.

Across all branching generators, the scale parameter $s_i$ controls the strength of deviation from linearity, determining slope, curvature, or growth rate depending on the branch geometry.

```{r branch-proj, eval=knitr::is_latex_output(), fig.cap="Three $2\\text{-}D$ projections from the $4\\text{-}D$ \\texttt{orgcurvybranches} data. Each shows a different projection, illustrating how the linear branches appear from multiple viewing angles. These views highlight the datasetâ€™s underlying branching structure and demonstrate how projections reveal patterns that are otherwise hidden in higher dimensions.", fig.width=12, fig.height=4, fig.pos="H", fig.pos="!ht"}

set.seed(20240412)

# Add plot label

interior_annotation <- function(label, position = c(0.92, 0.92), cex = 1, col="grey70") {
  annotation_custom(grid::textGrob(label = label,
                                   x = unit(position[1], "npc"), y = unit(position[2], "npc"),
                                   gp = grid::gpar(cex = cex, col=col)))
}

# Scale high-d data

# Center the data by subtracting the mean of each column
center_data <- function(data) {
  center_values <- colMeans(data)
  data_centered <- sweep(data, 2, center_values, FUN = "-")  # subtract means
  data_centered
}

# Get projection

get_projection <- function(projection, centered_data, axis_param) {

  projected <- as.matrix(centered_data) %*% projection
  projected_df <- projected |>
    tibble::as_tibble(.name_repair = "unique") |>
    dplyr::rename(c("proj1" = "...1",
                    "proj2" = "...2")) |>
    dplyr::mutate(ID = dplyr::row_number())

  limits <- axis_param$limits
  axis_scaled <- axis_param$axis_scaled
  axis_pos_x <- axis_param$axis_pos_x
  axis_pos_y <- axis_param$axis_pos_y
  threshold <- axis_param$threshold

  axes_obj <- gen_axes(
    proj = projection * axis_scaled,
    limits = limits,
    axis_pos_x = axis_pos_x,
    axis_pos_y = axis_pos_y,
    axis_labels = names(centered_data),
    threshold = threshold)

  axes <- axes_obj$axes
  circle <- axes_obj$circle

  return(list(projected_df = projected_df,
              axes = axes,
              circle = circle))

}

# Plot projection
plot_proj <- function(proj_obj,
                      point_param = c(1.5, 0.5, "#000000"), # size, alpha, color
                      plot_limits, title, cex = 2,
                      position = c(0.92, 0.92),
                      axis_text_size = 3,
                      is_color = FALSE) {

  projected_df <- proj_obj$projected_df
  axes <- proj_obj$axes
  circle <- proj_obj$circle

  if(is_color == FALSE) {

    initial_plot <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2),
        size = as.numeric(point_param[1]),
        alpha = as.numeric(point_param[2]),
        color = point_param[3])

  } else {

    projected_df <- projected_df |>
      dplyr::mutate(cluster = proj_obj$cluster)

    initial_plot <- ggplot() +
      geom_point(
        data = projected_df,
        aes(
          x = proj1,
          y = proj2,
          color = cluster),
        size = as.numeric(point_param[1]),
        alpha = as.numeric(point_param[2]))

  }

  initial_plot <- initial_plot +
    geom_segment(
      data=axes,
      aes(x=x1, y=y1, xend=x2, yend=y2),
      colour="grey70") +
    geom_text(
      data=axes,
      aes(x=x2, y=y2),
      label=rownames(axes),
      colour="grey50",
      size = axis_text_size) +
    geom_path(
      data=circle,
      aes(x=c1, y=c2), colour="grey70") +
    xlim(plot_limits) +
    ylim(plot_limits) +
    interior_annotation(title, position, cex = cex)

  initial_plot

}

# Generate axes

gen_axes <- function(proj, limits = 1, axis_pos_x = NULL, axis_pos_y = NULL, axis_labels, threshold) {

  axis_scale <- limits/6

  if (is.null(axis_pos_x)) {

    axis_pos_x <- -2/3 * limits

  }

  if (is.null(axis_pos_y)) {

    axis_pos_y <- -2/3 * limits

  }

  adj <- function(x, axis_pos) axis_pos + x * axis_scale
  axes <- data.frame(x1 = adj(0, axis_pos_x),
                     y1 = adj(0, axis_pos_y),
                     x2 = adj(proj[, 1], axis_pos_x),
                     y2 = adj(proj[, 2], axis_pos_y))

  rownames(axes) <- axis_labels

  ## To remove axes
  axes <- axes |>
    mutate(distance = sqrt((x2 - x1)^2 + (y2 - y1)^2)) |>
    filter(distance >= threshold)

  theta <- seq(0, 2 * pi, length = 50)
  circle <- data.frame(c1 = adj(cos(theta), axis_pos_x),
                       c2 = adj(sin(theta), axis_pos_y))

  return(list(axes = axes, circle = circle))

}


plot_hbe <- function(error_df) {

  ggplot(error_df,
         aes(x = a1,
             y = HBE,
             colour = method)) +
    geom_point(size = 0.8) +
    geom_line(linewidth = 0.3) +
    ylab("HBE") +
    xlab(expression(paste("binwidth (", a[1], ")"))) +
    theme_minimal() +
    theme(panel.border = element_rect(fill = 'transparent'),
          plot.title = element_text(size = 12, hjust = 0.5, vjust = -0.5),
          axis.ticks.x = element_line(),
          axis.ticks.y = element_line(),
          legend.position = "none",
          axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7),
          axis.title.x = element_text(size = 7),
          axis.title.y = element_text(size = 7),
          plot.margin = margin(0, 0, 0, 0))

}



orglinearbranches <- gen_orglinearbranches(n = 1000, p = 4, k = 4)


## First projection
projection <- cbind(
    c(-0.083573,-0.019043,0.006574,-0.035774),
    c(0.005380,0.068541,-0.030810,-0.054717))

proj_obj1 <- get_projection(projection = projection, 
                            centered_data = centered_data, 
                            axis_param = list(limits = 0.5,
                                              axis_scaled = 10, 
                                              axis_pos_x = -0.5, 
                                              axis_pos_y = -0.5, 
                                              threshold = 0.05))

orglinearbranches_proj1 <- plot_proj(
  proj_obj = proj_obj1, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-0.6, 0.4), 
  title = "a1", 
  cex = 2, 
  axis_text_size = 4,
  is_color = FALSE)


## Second projection
projection <- cbind(
  c(-0.06614,0.15134,-0.44278,0.27367),
  c(-0.50493,0.14388,0.14615,0.03486))

proj_obj2 <- get_projection(projection = projection, 
                            centered_data = centered_data, 
                            axis_param = list(limits = 0.9,
                                              axis_scaled = 1, 
                                              axis_pos_x = -0.85, 
                                              axis_pos_y = -0.85, 
                                              threshold = 0.05))

orglinearbranches_proj2 <- plot_proj(
  proj_obj = proj_obj2, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-1, 1), 
  title = "a2", 
  cex = 2, 
  axis_text_size = 4,
  is_color = FALSE)


## Third projection
projection <- cbind(
  c(0.10704,0.04822,-0.03416,0.53224),
  c(0.50329,0.07199,-0.16064,-0.11806))

proj_obj3 <- get_projection(projection = projection, 
                            centered_data = centered_data, 
                            axis_param = list(limits = 0.9,
                                              axis_scaled = 1.5, 
                                              axis_pos_x = -0.85, 
                                              axis_pos_y = -0.85, 
                                              threshold = 0.1))

orglinearbranches_proj3 <- plot_proj(
  proj_obj = proj_obj3, 
  point_param = c(1.5, 0.2, "#000000"), # size, alpha, color
  plot_limits = c(-1, 1), 
  title = "a3", 
  cex = 2, 
  axis_text_size = 4,
  is_color = FALSE)



orglinearbranches_proj1 + orglinearbranches_proj2 + orglinearbranches_proj3 +
  plot_layout(ncol = 3, guides = "collect") 
```
