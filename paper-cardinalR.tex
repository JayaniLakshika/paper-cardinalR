% !TeX root = RJwrapper.tex
\title{cardinalR: Generating interesting high-dimensional data structures}


\author{by Jayani P. Gamage, Dianne Cook, Paul Harrison, Michael Lydeamore, and Thiyanga S. Talagala}

\maketitle

\abstract{%
A high-dimensional dataset is one where each observation is described by many features, or dimensions, with associations between them. These datasets contain nonlinear manifolds in image and speech recognition, clusters in genomics and forensic analysis, and sparse distributions in text mining. Data with a variety of structures can be generated using mathematical functions and statistical distributions to create test datasets. High-dimensional data structures are useful for testing, validating, and improving algorithms used in dimensionality reduction, clustering, machine learning, and visualization. Their controlled complexity allows researchers to understand challenges posed in data analysis and helps to develop robust analytical methods across diverse scientific fields like bioinformatics, machine learning, and forensic science. Functions to generate a large variety of structures in high dimensions are organized into the R package \texttt{cardinalR}, along with some already generated examples, adding to the existing toolset of benchmark datasets for evaluating algorithms.
}

\section{Introduction}\label{introduction}

Generating synthetic datasets with clearly defined geometric properties is useful for evaluating and benchmarking algorithms in various fields, such as machine learning, data mining, and computational biology. Researchers often need to generate data with specific dimensions, noise characteristics, and complex underlying structures to test the performance and robustness of their methods. There are numerous packages available in R for generating synthetic data, each designed with unique characteristics and focus areas.The \texttt{geozoo} package (\citet{barret2016}) offers a large collection of geometric objects, allowing users to create and analyze specific shapes, primarily in lower-dimensional spaces. The package is \texttt{snedata} (\citet{james2025}), which provides tools for generating simplified datasets useful for evaluating dimensionality reduction techniques like tSNE, often focusing on understanding and evaluating low-dimensional embeddings of complex data structures. Additionally, \texttt{splatter} (\citet{luke2017}) is designed to simulate complex biological data, capturing field-specific nuances such as batch effects and differential expression. In contrast, \texttt{mlbench} (\citet{friedrich2024}) includes a collection of well-known benchmark datasets commonly associated with established classification or regression challenges. The \texttt{surreal} package (\citet{james2024}) implements the ``Residual (Sur)Realism'' algorithm (\citet{leonard2007}) to generate datasets that embed hidden images or text into residual plots, providing engaging visual demonstrations for teaching model diagnostics. Meanwhile, the \texttt{DHARMa} package (\citet{florian2024}) adopts a simulation-based approach to create scaled quantile residuals for generalized linear (mixed) models and related frameworks, supporting model diagnostics through intuitive residuals, plots, and tests for common misspecification issues.

While these packages are valuable, their scope is often limited to specific applications or low-dimensional structures. To address this gap, this paper introduces the \texttt{cardinalR} R package. This package provides a collection of functions designed to generate customizable data structures in any number of dimensions, starting from basic geometric shapes. \texttt{cardinalR} offers important functionalities that extend beyond the capabilities of existing tools, allowing users to: (i) construct high-dimensional datasets based on geometric shapes, including the option to enhance dimensionality by adding controlled noise dimensions; (ii) introduce adjustable levels of background noise to these structures; and (iii) combine high-dimensional datasets into a single multi-faceted, clustered dataset in a space of arbitrary dimension. By using clearly defined geometric shapes and controllable characteristics such as number of dimensions, sample size; \texttt{cardinalR} allows researchers to generate transparent and interpretable synthetic datasets useful for evaluating the performance of nonlinear dimensionality reduction (NLDR) methods, clustering algorithms, and visualization techniques. Moreover, these datasets can serve as benchmark examples for exploring how different algorithmic choices affect the identification or representation of cluster and manifold structures in high-dimensional spaces.

The paper is organized as follows. In the next section, we introduce the implementation of the \texttt{cardinalR} package on GitHub, including a demonstration of the package's key functions. We illustrate how a clustering data structure affects the dimension reductions in the Application section. Finally, we give a brief conclusion of the paper and discuss potential opportunities for the use of our data collection.

\section{Implementation}\label{implementation}

The \texttt{cardinalR} R package is available on GitHub at \href{https://github.com/JayaniLakshika/cardinalR}{JayaniLakshika/cardinalR}.

\subsection{Usage}\label{usage}

\subsubsection{Main function}\label{main-function}

The main function of the package is \texttt{gen\_multicluster()}, which generates datasets consisting of multiple clusters with user-specified characteristics. Users can control the number of clusters (\texttt{k}), and the number of points in each cluster (\texttt{n}). Each cluster can take on a different geometric shape (e.g., Gaussian, cone, uniform cube) by specifying the corresponding generator function (\texttt{shape}), can be scaled to adjust its spread, rotated using custom rotation matrices (\texttt{rotation}), and positioned at defined centroids (\texttt{loc}). The function ensures flexibility in cluster location and orientation, allowing users to simulate complex high-dimensional structures.

To maintain consistency across generators, the function identifies the arguments required by each chosen generator function and supplies only those arguments that are valid for that specific generator. This design enables the combination of cluster types with differing parameter requirements within the same dataset. When clusters are generated with fewer dimensions than others, the function augments the lower-dimensional clusters with additional Gaussian noise variables so that all clusters are represented in the same dimensional space. These noise dimensions are drawn independently from normal distributions

\[
X \sim \mathcal{N}(m, s^2),
\]

where the mean (\(m\)) is set to the average of the cluster coordinates and the standard deviation (\(s\)) defaults to \(0.2\).

An optional argument, \texttt{is\_bkg}, adds background noise drawn from a multivariate normal distribution centered on the dataset's overall mean with standard deviations matching the observed spread. Extra arguments (\texttt{...}) can be passed to cluster generators, allowing further control over per-cluster characteristics like radius of the sphere.

The main arguments of the \texttt{gen\_multicluster()} function are shown in Table \ref{tab:main-tb-pdf}.

\begin{table}

\caption{\label{tab:main-tb-pdf}The main arguments for gen\_multicluster().}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{2cm}>{\raggedright\arraybackslash}p{3cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Argument & Type & Explanation\\
\midrule
n & numeric (vector) & Number of points in each cluster.\\
k & numeric & Number of clusters.\\
loc & numeric (matrix) & Locations/centroids of clusters.\\
scale & numeric (vector) & Scaling factors of clusters.\\
shape & character (vector) & Shapes of clusters.\\
\addlinespace
rotation & numeric (list) & Rotation matrices, one per cluster.\\
is\_bkg & boolean & Background noise should exist or not.\\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Shape generators}\label{shape-generators}

The shape generators form the foundation of the package, providing a collection of functions to create synthetic data structures based on simple, well-defined geometric structures. These include fundamental shapes such as cones, pyramids, spheres, grids, and branching structures. If a shape is not inherently defined in more than two dimensions, additional noise dimensions can be added to embed the structure into higher-dimensional space. Users can specify how these noise dimensions are generated (e.g., Gaussian, wavy) (\texttt{noise\_fun}), offering control over the embedding process. All shape generators allow the user to define the number of points (\texttt{n}), and most include additional arguments to customize specific characteristics of the structure.

\paragraph{Branching}\label{branching}

A branching structure (Figure \ref{fig:branch-proj}) captures trajectories that diverge or bifurcate from a common origin, similar to processes such as cell differentiation in biology (\citet{trapnell2014}). We introduce a set of data generation functions specifically designed to simulate high-dimensional branching structures with various geometries, numbers of points (\texttt{n}), and number of branches (\texttt{k}). Although these functions can generate multiple branches, they do not produce a formal \emph{multicluster} dataset: the branches form a single connected structure, with multiple visually distinct arms rather than independent clusters. Table \ref{tab:branching-tb-pdf} outlines these functions. The main arguments of the functions described in Table \ref{tab:arg-branching-tb-pdf}.

\begin{table}

\caption{\label{tab:branching-tb-pdf}cardinalR branching data generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_expbranches & Exponential shaped branches.\\
gen\_linearbranches & Linear shaped branches.\\
gen\_curvybranches & Curvy shaped branches.\\
gen\_orglinearbranches & Linear shaped branches originated in one point.\\
gen\_orgcurvybranches & Curvy shaped branches originated in one point.\\
\bottomrule
\end{tabular}
\end{table}

\begin{table}

\caption{\label{tab:arg-branching-tb-pdf}The main arguments for branching shape generators.}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Argument & Explanation\\
\midrule
n & A numeric value representing the number of points.\\
p & A numeric value representing the number of dimensions.\\
k & A numeric value representing the number of clusters.\\
\bottomrule
\end{tabular}
\end{table}

The simplest structures are approximately linear branches, generated by the \texttt{gen\_linearbranches(n,\ p,\ k)} function (Figure \ref{fig:branch-proj} b). These consist of \(k\) short line segments in the first two dimensions, with added jitter to simulate variability. Mathematically, each branch \(i\) is defined as

\[
X_1 \sim U(a_i, b_i), \quad X_2 = s_i (X_1 - x_{\text{start},i}) + y_{\text{start},i} + \epsilon, \quad \epsilon \sim U(0, \delta),
\]

where \((x_{\text{start},i}, y_{\text{start},i})\) is the starting point of branch \(i\), \(\delta\) controls local jitter, and \(s_i\) is the slope, initialized as

\[
s_i =
\begin{cases}
0.5 & i = 1, \\
-0.5 & i = 2, \\
\text{randomly sampled from } [s_{\min}, s_{\max}] & i = 3, \dots, k.
\end{cases}
\]

Branches \(1\) and \(2\) are initialized with fixed slopes and intercepts, while later branches are iteratively added at locations chosen to avoid overlap with existing branches, producing a set of connected linear paths.

\begin{verbatim}
linearbranches <- gen_linearbranches(n = 1000, k = 4)
\end{verbatim}

To introduce curvature, the \texttt{gen\_curvybranches(n,\ p,\ k)} function generates \(k\) curvilinear branches in \(p\text{-}D\) (Figure \ref{fig:branch-proj} c). Branches \(1\) and \(2\) are simple parabolas defined as

\[
\begin{aligned}
\text{Branch 1: } & X_1 \sim U(0,1), \quad X_2 = 0.1 X_1 + X_1^2 + \epsilon, \\
\text{Branch 2: } & X_1 \sim U(-1,0), \quad X_2 = 0.1 X_1 - 2 X_1^2 + \epsilon, \quad \epsilon \sim U(0, \delta),
\end{aligned}
\]

where \(\delta\) controls local jitter. Additional branches are attached iteratively to existing structures. Each new branch \(i\) starts at a selected point \((x_{\text{start},i}, y_{\text{start},i})\) from the current structure and extends according to

\[
X_1 \sim U(x_{\text{start},i}, x_{\text{start},i}+1), \quad X_2 = 0.1 X_1 - s_i (X_1^2 - x_{\text{start},i}) + y_{\text{start},i},
\]

where \(s_i\) is a scale factor controlling the curvature of branch \(i\). For the first few initial branches, \(s_i\) can be fixed (e.g., \(s_1 = 1, s_2 = 2\)), while for subsequent branches it is sampled from a predefined set, such as \(s_i \in \{-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5\}\), to create variability in curvature.

\begin{verbatim}
curvybranches <- gen_curvybranches(n = 1000, k = 4)
\end{verbatim}

The \texttt{gen\_expbranches(n,\ p,\ k)} function creates \(k\) exponential branches in \(2\text{-}D\), radiating from a central region (Figure \ref{fig:branch-proj} a). Each branch \(i\) is defined as

\[
X_1 \sim U(-2,2), \quad X_2 = \exp(\sigma_i \, s_i \, X_1) + \epsilon, \quad \epsilon \sim U(0, \delta), \quad s_i \sim U(0.5,2),
\]

where \(\sigma_i = (-1)^{i+1}\) alternates the sign of the exponent to produce mirror-symmetric branches. The parameter \(s_i\) controls the steepness of branch \(i\), and \(\delta\) introduces small local jitter.

\begin{verbatim}
expbranches <- gen_expbranches(n = 1000, k = 4)
\end{verbatim}

High-dimensional generalizations are provided by \texttt{gen\_orglinearbranches(n,\ p,\ k)} and \texttt{gen\_orgcurvybranches(n,\ p,\ k)} (Figure \ref{fig:branch-proj} d-e). Each branch is embedded in a unique or repeated \(2\text{-}D\) subspace of the \(p\text{-}D\) space. When \texttt{allow\_share\ =\ TRUE}, multiple branches may share the same subspace; otherwise, subspaces are sampled without replacement until all possible \(\binom{p}{2}\) combinations are exhausted, after which additional branches may repeat subspaces. Linear branches follow

\[
X_{i_1} \sim U(a_i,b_i), \quad X_{i_2} = s_i X_{i_1} + \epsilon, \quad \epsilon \sim N(0, \sigma^2),
\]

while curvilinear branches include a quadratic term

\[
X_{i_1} \sim U(a_i,b_i), \quad X_{i_2} = - s_i X_{i_1}^2 + \epsilon, \quad \epsilon \sim N(0, \sigma^2),
\]

where \(a_i, b_i\) define the range of the first coordinate for branch \(i\), and \(\epsilon\) is Gaussian noise added to introduce variability. The scale factor \(s_i\) controls slope (linear branches) or curvature (curvilinear branches) and is assigned as follows: for the first \(\binom{p}{2}\) branches, \(s_i = 1\); for additional branches when \(k > \binom{p}{2}\), \(s_i\) is randomly drawn from the set \(\{1, 1.5, 2, \dots, 8\}\).

\begin{verbatim}
orglinearbranches <- gen_orglinearbranches(n = 1000, p = 4, k = 4)
\end{verbatim}

\begin{verbatim}
orgcurvybranches <- gen_orgcurvybranches(n = 1000, p = 4, k = 4)
\end{verbatim}

For all branch-generating functions, when the target dimensionality \(p > 2\), additional dimensions are filled with independent noise, allowing the \(2\text{-}D\) or \(2\text{-}D\)-subspace structures to be naturally embedded in higher-dimensional space while preserving the intended geometric patterns.

\begin{figure}[!]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/branch-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `expbranches` (a1-a3), `linearbranches` (b1-b3), `curvybranches` (c1-c3), `orglinearbranches` (d1-d3), `orgcurvybranches` (e1-e3) data.}\label{fig:branch-proj}
\end{figure}

\paragraph{Cube}\label{cube}

A cube structure (Figure \ref{fig:cube-proj}) represents uniformly or systematically distributed points within a high-dimensional hypercube, providing a useful framework for assessing how well algorithms preserve uniformity, spacing, and boundary properties in high dimensions. We provide a set of functions to generate high-dimensional cube structures with flexible configurations, including regular grids, uniform random points, and cubes with missing regions or holes. These structures are valuable for testing the ability of algorithms to maintain uniform spacing or to detect gaps in the data. Table \ref{tab:cube-tb-pdf} outlines these functions and their purposes.

The first is the regular grid of points of \(n\) points in \(p\) dimensions. This is generated using \texttt{gen\_gridcube(n,\ p)}. The number of grid points along each axis is determined by finding the nearest integer factors whose product is close to \(n\). Each dimension is then normalized to lie in the interval \([0,1]\), so that the resulting structure forms a true \(p\text{-}D\) hypercube. This produces a lattice of evenly spaced points along all axes, providing a uniform and interpretable high-dimensional grid.

\begin{verbatim}
gridcube <- gen_gridcube(n = 1000, p = 4)
\end{verbatim}

An extension to the regular grid of points is to consider the points being uniformly distributed along each axis, as opposed to evenly spaced. The function \texttt{gen\_unifcube(n,\ p)} is identical to the regular grid of points, except instead of points being placed in integer grid coordinates, they are placed at a uniformly distributed point inside the \(p\text{-}D\) cube (Figure \ref{fig:cube-proj} b).

\begin{verbatim}
unifcube <- gen_unifcube(n = 1000, p = 4)
\end{verbatim}

\begin{table}

\caption{\label{tab:cube-tb-pdf}cardinalR cube data generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_gridcube & Cube with specified grid points along each axes.\\
gen\_unifcube & Cube with uniform points.\\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[!]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/cube-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `gridcube` (a1-a3), `unifcube` (b1-b3), and `cubehole` (c1-c3) data.}\label{fig:cube-proj}
\end{figure}

\paragraph{Cone}\label{cone}

To simulate a cone-shaped structure in arbitrary dimensions (Figure \ref{fig:cone-proj}), we define a function \texttt{gen\_cone(n,\ p,\ h,\ ratio)}, which creates a high-dimensional cone with options for a sharp or blunted apex, allowing for a dense concentration of points near the tip.

This function generates \(n\) points in \(p\text{-}D\), where the last dimension, \(X_p\), represents the height along the cone's axis, and the first \(p-1\) dimensions define a shrinking hyperspherical cross-section toward the tip. Heights are sampled from a truncated exponential distribution, \(X_p \sim \text{Exp}(\lambda = 2/h)\), capped at the cone height \(h\), producing a higher density of points near the tip. At each height \(X_p\), the radius of the cross-section decreases linearly from base to tip according to \(r = r_{\text{min}} + (r_{\text{max}} - r_{\text{min}}) X_p / h\), where \(r_{\text{min}} = \text{ratio}\) and \(r_{\text{max}} = 1\).

For each point, a direction in the first \(p-1\) dimensions is sampled uniformly on a \((p-1)\)-dimensional hypersphere using generalized spherical coordinates. The radial coordinates are scaled by the height-dependent radius \(r\), producing the conical taper. In three dimensions (\(p = 3\)), this results in a classical \(3\text{-}D\) cone, while for \(p > 3\), additional dimensions provide a smooth embedding into higher-dimensional space, preserving the conical structure.

\begin{verbatim}
cone <- gen_cone(n = 1000, p = 4, h = 5, ratio = 0.5)
\end{verbatim}

\begin{figure}[!]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/cone-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `cone` data.}\label{fig:cone-proj}
\end{figure}

\paragraph{Linear}\label{linear}

The \texttt{gen\_longlinear(n,\ p)} function generates a high-dimensional dataset representing a long linear structure with noise. Each variable is formed as \(X_i = \text{scale}_i \cdot (0,1,\dots,n{-}1 + \epsilon) + \text{shift}_i\), where \(\text{scale}\_i \sim U(-10, 10)\) determines the orientation of the line in each dimension, \(\text{shift}\_i \sim U(-300, 300)\) offsets the line to separate dimensions, and \(\epsilon \sim N(0, (0.03n)^2)\) introduces Gaussian noise.

\begin{verbatim}
linear <- gen_longlinear(n = 1000, p = 4)
\end{verbatim}

\begin{figure}[!]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/linear-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `linear` data.}\label{fig:linear-proj}
\end{figure}

\paragraph{Gaussian}\label{gaussian}

The \texttt{gen\_gaussian(n,\ p,\ s)} function generates a multivariate Gaussian cloud in \(p\text{-}D\), centered at the origin with user-defined covariance structure. Each point is independently drawn using the multivariate normal distribution with \(X_i \sim N_p(\boldsymbol{0}, s)\), where \(s\) is a user-defined \(p \times p\) positive-definite matrix.

\begin{verbatim}
gau <- gen_gaussian(n = 1000, p = 4, s = diag(4))
\end{verbatim}

\paragraph{Möbius}\label{muxf6bius}

The \texttt{gen\_mobius()} function is a \textbf{wrapper} around \texttt{geozoo::mobius()}, designed to simplify the generation of a Möbius strip in three dimensions for use in high-dimensional diagnostic studies. The function returns a tibble with \(n\) sampled points forming the surface of a Möbius strip.

\begin{verbatim}
mobius <- gen_mobius(n = 1000)
\end{verbatim}

\paragraph{Pyramid}\label{pyramid}

A pyramid structure (Figure \ref{fig:pyr-proj}) represents data arranged around a central apex and base, useful for exploring how algorithms handle pointed or layered geometries in high-dimensional space. The functions provided allow users to generate pyramids with rectangular, triangular, and star-shaped bases, and sharp or blunted apexes. Additionally, it is possible to create a pyramid with a fractal-like internal structure, enabling the study of non-convex and sparse regions. Table \ref{tab:pyramid-tb-pdf} summarizes these functions.

Let \(X_1, \dots, X_p\) denote the coordinates of the generated points. For the rectangular and triangular based pyramid generator functions, the final dimension, \(X_p\), encodes the height of each point and is drawn from an exponential distribution capped at the maximum height \(h\). That is, \[X_p = z \sim \min\left(\text{Exp}(\lambda = 2/h),\ h\right).\] This distribution creates a natural skew toward smaller height values, resulting in a denser concentration of points near the pyramid's apex. For the star-shaped base pyramid, the final dimension is drawn from a uniform distribution. That is, \(X_p = z \sim U(0, h)\).

The remaining dimensions are based on the specific pyramid shape. For the rectangular based pyramid, \texttt{gen\_pyrrect(n,\ p,\ h,\ l\_vec,\ rt)} (Figure \ref{fig:pyr-proj} a), let \(r_x(z)\) and \(r_y(z)\) denote the half-widths of the rectangular cross-section at height \(z\). That is, \(r_x(z) = r_t + (l_x - r_t)z/h\), \(r_y(z) = r_t + (l_y - r_t)z/h\). The first three coordinates are then defined as: \[X_1 \sim U(-r_x(z),\ r_x(z)), \quad X_2 \sim U(-r_y(z),\ r_y(z)),\text{ and }X_3 \sim U(-r_x(z),\ r_x(z)).\]

\begin{verbatim}
pyrrect <- gen_pyrrect(n = 1000, p = 4)
\end{verbatim}

For the triangular based pyramid, \texttt{gen\_pyrtri(n,\ p,\ h,\ l,\ rt)} (Figure \ref{fig:pyr-proj} b), let \(r(z)\) denote the scaling factor (distance from the origin to triangle vertices) at height \(z\). That is, \(r(z) = r_t + (l-r_t)z/h\). A point in the triangle at height \(z\) is generated using barycentric coordinates \((u, v)\) to ensure uniform sampling within the triangular cross-section: \(u, v \sim U(0, 1), \quad \text{if } u + v > 1: u \leftarrow 1 - u,\ v \leftarrow 1 - v\). The first three coordinates (triangle plane) are then: \(X_1 = r(z)(1 - u - v)\), \(X_2 = r(z)u\), and \(X_3 = r(z)v.\)

\begin{verbatim}
pyrtri <- gen_pyrtri(n = 1000, p = 4)
\end{verbatim}

For the star based pyramid, \texttt{gen\_pyrstar(n,\ p,\ h,\ rb)} (Figure \ref{fig:pyr-proj} c), let the radius at height \(z\), \(r(z)\), be such that the radius scales linearly from zero (tip) to the base radius \(r_b\). That is, \(r(z) = r_b\left(1 - z/h\right)\).

Each point is placed within a regular hexagon in the plane \((X_1, X_2)\), using a randomly chosen hexagon sector angle \(\theta \in \{0, \pi/3, 2\pi/3, \pi, 4\pi/3, 5\pi/3\}\) and a uniformly random radial scaling factor: \(\theta \sim \text{Uniform sample from 6 hexagon angles}\),
\(r_{\text{point}} \sim \sqrt{U(0, 1)}\). Then, the first two coordinates are: \(X_1 = r(z)r_{\text{point}}\cos(\theta)\), and \(X_2 = r(z)r_{\text{point}}\sin(\theta)\).

\begin{verbatim}
pyrstar <- gen_pyrstar(n = 1000, p = 4)
\end{verbatim}

For all the above pyramid shapes, if \(p > 3\), the remaining \(p - 3\) dimensions (i.e., \(X_4\) to \(X_{p-1}\)) are additional noise.

Finally, for the Sierpinski-like pyramid, \texttt{gen\_pyrfrac(n,\ p)} (Figure \ref{fig:pyr-proj} d), let \(X_1, X_2, \dots, X_p\) denote the coordinates of the generated points. The generation process begins with an initial point \(T_0 \in [0, 1]^p\) drawn from a uniform distribution: \(T_0 \sim U(0, 1)^p\). Let \(C_1, C_2, \dots, C_{p+1}\) denote the corner vertices of a \(p\text{-}D\) simplex. At each iteration \(i = 1, \dots, n\), a new point is computed by taking the midpoint between the previous point \(T_{i-1}\) and a randomly selected vertex \(C_k\): \(T_i = 1/2(T_{i-1} + C_k), \quad C_k \in \{C_1, \dots, C_{p+1}\}\). This recursive midpoint rule generates self-similar patterns with systematic voids (holes) between clusters of points. The points remain bounded inside the convex hull of the simplex. The final output is a \(n \times p\) matrix where each row represents a point: \(X = \{T_1, T_2, \dots, T_n\}, \quad X \in \mathbb{R}^{n \times p}\).

\begin{verbatim}
pyrholes <- gen_pyrfrac(n = 1000, p = 4)
\end{verbatim}

\begin{table}

\caption{\label{tab:pyramid-tb-pdf}cardinalR pyramid data generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_pyrrect & Rectangular-base pyramid, with a sharp or blunted apex.\\
gen\_pyrtri & Triangular-base pyramid, with a sharp or blunted apex.\\
gen\_pyrstar & Star-shaped base pyramid, with a sharp or blunted apex.\\
gen\_pyrfrac & Pyramid containing triangular pyramid-shaped holes.\\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[!]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/pyr-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `pyrrect` (a1-a3), `pyrtri` (b1-b3), `pyrstar` (c1-c3), and `pyrholes` (d1-d3) data.}\label{fig:pyr-proj}
\end{figure}

\paragraph{Polynomial}\label{polynomial}

A polynomial structure generates data points that follow non-linear curvilinear relationships, such as quadratic or cubic trends, in $2\text{-}D${} space. To extend these patterns into high-dimensional settings, additional noise dimensions can be added. These patterns are useful for evaluating how well algorithms capture smooth, non-linear trajectories and curvature in the data. We provide functions for generating quadratic and cubic structures, enabling controlled experiments with different degrees of polynomial complexity. Table \ref{tab:polynomial-tb-pdf} summarizes these functions and their purposes.

\begin{table}

\caption{\label{tab:polynomial-tb-pdf}cardinalR polynomial data generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_quadratic & Quadratic pattern.\\
gen\_cubic & Cubic pattern.\\
\bottomrule
\end{tabular}
\end{table}

The first is the quadratic curve of \(n\) points in two dimensions. This is generated using \texttt{gen\_quadratic(n,\ range)}. The independent variable is defined as \(X_1 \sim U(\text{range}[1], \text{range}[2])\), and a raw polynomial basis of degree 2 is applied to form \(X_2 = X_1 - X_1^2 + \varepsilon_2\), where \(\varepsilon_2 \sim U(0, 0.5)\). This produces a smooth parabolic arc opening downward, with vertical jitter introduced by the noise term.

\begin{verbatim}
quadratic <- gen_quadratic(n = 1000)
\end{verbatim}

The second is the cubic curve of \(n\) points in two dimensions. This is generated using \texttt{gen\_cubic(n,\ range)}. The independent variable is defined as \(X_1 \sim U(\text{range}[1], \text{range}[2])\), and a raw polynomial basis of degree \(3\) is applied to construct \(X_2 = X_1 + X_1^2 - X_1^3 + \varepsilon_2\), where \(\varepsilon_2 \sim U(0, 0.5)\). This produces a more complex curvilinear structure than the quadratic case, with both upward and downward turning points.

\begin{verbatim}
cubic <- gen_cubic(n = 1000)
\end{verbatim}

\paragraph{S-curve}\label{s-curve}

An S-curve structure (Figure \ref{fig:scurve-proj}) simulates data that lies along a smooth, non-linear manifold.

For the S-curve structure, \texttt{gen\_scurve(n,\ p)} (Figure \ref{fig:scurve-proj} a), the \(3\text{-}D\) geometry is constructed by introducing a latent parameter, \(\theta \sim U\left(-3\pi/2, 3\pi/2\right)\). This parameter controls the curvature of the manifold. The first three dimensions form the S-curve structure: \[X_1 = \sin(\theta), \quad X_2 \sim U(0, 2), \quad X_3 = \text{sign}(\theta)(\cos(\theta) - 1)\]. This configuration creates a horizontally curled shape in \((X_1, X_3)\), with additional band thickness in the \(X_2\) direction.

\begin{verbatim}
scurve <- gen_scurve(n = 1000)
\end{verbatim}

\begin{figure}[!]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/scurve-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `scurve` (a1-a3) and `scurvehole` (b1-b3) data.}\label{fig:scurve-proj}
\end{figure}

\paragraph{Sphere}\label{sphere}

Sphere-shaped structures (Figure \ref{fig:sphere-proj}) are useful for evaluating how dimension reduction and clustering algorithms handle curved, symmetric manifolds in high-dimensional spaces. The functions generate a variety of spherical forms, including simple circles, uniform spheres, grid-based spheres, and complex arrangements like clustered spheres within a larger sphere. The first few coordinates define the main geometric form (circle, cycle, sphere, or hemisphere), while higher-dimensional embeddings are achieved by adding noise dimensions. Table \ref{tab:sphere-tb-pdf} summarizes these functions.

\begin{table}

\caption{\label{tab:sphere-tb-pdf}cardinalR sphere data generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_circle & Circle.\\
gen\_curvycycle & Curvy cell cycle.\\
gen\_unifsphere & Uniform sphere.\\
gen\_gridedsphere & Grided sphere.\\
gen\_clusteredspheres & Multiple small spheres within a big sphere.\\
\addlinespace
gen\_hemisphere & Hemisphere.\\
\bottomrule
\end{tabular}
\end{table}

The simplest case, \texttt{gen\_circle(n)} creates a unit circle in two dimensions, with the remaining dimensions forming sinusoidal extensions of the angular parameter at progressively smaller scales (Figure \ref{fig:sphere-proj} a). Let a latent angle variable \(\theta\) is uniformly sampled from the interval \([0, 2\pi]\). Coordinates in the first two dimensions represent a perfect circle on the plane: \[X_1 = \cos(\theta), \quad X_2 = \sin(\theta)\]. For dimensions \(X_3\) through \(X_p\), sinusoidal transformations of the angle \(\theta\) are introduced. The first component is a scaling factor that decreases with the dimension index, defined as \(\text{scale}_j = \sqrt{(0.5)^{j-2}}\) for \(j = 3, \dots, p\). The second component is a phase shift that is proportional to the dimension index, specifically designed to decorrelate the curves, given by the formula \(\phi_j = (j - 2)\pi/2p\). Each additional dimension is computed as: \(X_j = \text{scale}_{j}\sin(\theta + \phi_j), \quad j = 3, \dots, p\).

\begin{verbatim}
circle <- gen_circle(n = 1000, p = 4)
\end{verbatim}

For the one-dimensional nonlinear cycle embedded in \(p\text{-}D\) space, \texttt{gen\_curvycycle(n)} (Figure \ref{fig:sphere-proj} b), let a latent angle variable \(\theta\) is uniformly sampled from the interval \([0, 2\pi]\). The first three dimensions define a non-circular closed curve, referred to as a ``curvy cycle''. In this configuration, \(X_1 = \cos(\theta)\) represents horizontal oscillation, while \(X_2 = \sqrt{3}/3 + \sin(\theta)\) introduces a vertical offset to avoid centering the curve at the origin. Additionally, \(X_3 = 1/3\cos(3\theta)\) introduces a third harmonic perturbation that intricately folds the curve three times along its path, creating a unique and complex shape that oscillates in both dimensions while incorporating the effects of the harmonic perturbation.

Together, these define a periodic, non-trivial, closed curve in \(3\text{-}D\) with internal folds that produce a more complex geometry than a standard circle or ellipse. For dimensions \(X_4\) through \(X_p\), additional structured variability is introduced through decreasing amplitude scaling and phase-shifted sine waves. The scaling factor is defined as \(\text{scale}_j = \sqrt{(0.5)^{j-3}}\) for \(j\) ranging from \(4\) to \(p\), which means that the amplitude decreases as the dimension increases. Each dimension \(X_j\) is then calculated using the formula \(X_j = \text{scale}_j\sin(\theta + \phi_j)\), where the phase shift \(\phi_j\) is given by \(\phi_j = (j - 2)\pi/2p\).

\begin{verbatim}
curvycycle <- gen_curvycycle(n = 1000, p = 4)
\end{verbatim}

Building on simple circular structures, the \texttt{gen\_unifsphere(n,\ r)} function function extends the idea to three dimensions by generating \(n\) observations approximately uniformly distributed on the surface of a sphere of radius \(r\), with optional high-dimensional noise when \(p > 3\) (Figure \ref{fig:sphere-proj} c). Each observation is computed from spherical coordinates, with \(u \sim U(-1, 1)\) representing \(\cos(\phi)\) and \(\theta \sim U(0, 2\pi)\) the azimuthal angle. Cartesian coordinates are then defined as \[X_1 = r\sqrt{1 - u^2}\cos(\theta), \quad X_2 = r\sqrt{1 - u^2}\sin(\theta),\text{ and }X_3 = ru,\] ensuring uniform distribution on the surface (not within) of the sphere.

\begin{verbatim}
unifsphere <- gen_unifsphere(n = 1000, r = 1)
\end{verbatim}

In contrast, the \texttt{gen\_hollowsphere(n,\ p)} function, a wrapper around \texttt{geozoo::sphere.hollow()}, generates \(n\) points uniformly distributed \textbf{only on the surface} of the \((p-1)\)-dimensional sphere embedded in \(\mathbb{R}^p\). This results in a hollow shell-like structure with no interior points.

For example, when \(p=3\), \texttt{gen\_unifsphere()} produces a solid ball in 3D space, whereas \texttt{gen\_hollowsphere()} produces only the spherical boundary. These paired structures allow controlled experiments to investigate how algorithms behave when data is concentrated throughout the full volume versus constrained to the boundary.

\begin{verbatim}
hollowsphere <- gen_hollowsphere(n = 1000, p = 4)
\end{verbatim}

In addition, the \texttt{gen\_gridedsphere(n)} function constructs a \(p\text{-}D\) dataset consisting of approximately \(n\) points that are evenly distributed on the surface of the unit \((p-1)\)-sphere embedded in \(\mathbb{R}^p\) (Figure \ref{fig:sphere-proj} d). The method relies on forming a regular grid in spherical coordinates, parameterized by \((p-1)\) angular variables: for dimensions \(j = 1, \dots, p-2\) the polar angles are drawn from \([0, \pi]\), while the final angle (\(j = p-1\)) represents the azimuth and is drawn from \([0, 2\pi]\). The number of grid steps along each angular dimension is chosen by decomposing \(n\) into \((p-1)\) approximately equal integer factors using the helper function \texttt{gen\_nproduct(n,\ p\ -\ 1)}.

Each grid point is subsequently mapped into Cartesian space via the standard hyperspherical-to-Cartesian transformation,

\[
\begin{aligned}
X_1 &= \cos(\theta_1), \\
X_2 &= \sin(\theta_1)\cos(\theta_2), \\
X_3 &= \sin(\theta_1)\sin(\theta_2)\cos(\theta_3), \\
&\;\;\vdots \\
X_{p-1} &= \sin(\theta_1)\sin(\theta_2)\cdots \sin(\theta_{p-2})\cos(\theta_{p-1}), \\
X_p &= \sin(\theta_1)\sin(\theta_2)\cdots \sin(\theta_{p-2})\sin(\theta_{p-1}).
\end{aligned}
\]

The result is a deterministic grid of points lying exactly on the surface of the unit \((p-1)\)-sphere, without any additional noise dimensions.

\begin{verbatim}
gridedsphere <- gen_gridedsphere(n = 1000, p = 4)
\end{verbatim}

For more heterogeneous structures, the \texttt{gen\_clusteredspheres(n,\ k,\ r,\ loc)} function generates one large sphere of radius \(r_1\) and \(k\) smaller spheres of radius \(r_2\), each centered at a different random location (Figure \ref{fig:sphere-proj} e). A large uniform sphere centered at the origin is created by sampling \(n_1\) points uniformly on the surface of a \(p\text{-}D\) sphere with a radius of \(r_1\). The sampling is executed using the function \texttt{gen\_unifsphere(n\_1,\ p,\ r\_1)}, which generates the desired points in the specified dimensional space. In generation of \(k\) smaller uniform spheres, each sphere contains \(n_2\) points that are sampled uniformly on a sphere with a radius of \(r_2\). These spheres are positioned at distinct random locations in \(p\)-space, with the center of each sphere being drawn from a normal distribution \(N(0, \texttt{loc}^2 I_p)\). Points on spheres are generated using the standard hyperspherical method, which involves sampling \(u \sim U(-1, 1)\) to determine the cosine of the polar angle, and sampling \(\theta \sim U(0, 2\pi)\) to determine the azimuthal angle (for \(3\text{-}D\)). Each observation is classified by cluster, with labels such as ``big'' for the large central sphere and ``small\_1'' to ``small\_k'' for the smaller spheres.

\begin{verbatim}
clusteredspheres <- gen_clusteredspheres(n = c(1000, 100), k = 3, r = c(15, 3),
                                         loc = 10 / sqrt(3)) |>
  dplyr::select(-cluster)
\end{verbatim}

Finally, the \texttt{gen\_hemisphere(n,\ p)} function restricts sampling to a hemisphere of a \(4\text{-}D\) sphere (Figure \ref{fig:sphere-proj} f). Using spherical coordinates, the azimuthal angle \(\theta_1 \sim U(0, \pi)\) in the \((x_1, x_2)\) plane, while the elevation angle \(\theta_2 \sim U(0, \pi)\) in the \((x_2, x_3)\) plane. Additionally, \(\theta_3 \sim U(0, \pi/2)\) in the \((x_3, x_4)\) plane, ensuring that the points remain restricted to a hemisphere. The coordinates are transformed into \(4\text{-}D\) Cartesian space: \[X_1 = \sin(\theta_1)\cos(\theta_2), \quad X_2 = \sin(\theta_1)\sin(\theta_2), \quad X_3 = \cos(\theta_1)\cos(\theta_3), \quad X_4 = \cos(\theta_1)\sin(\theta_3).\] This produces points on one side of a \(4\text{-}D\) unit sphere, effectively generating a \(4\text{-}D\) hemisphere.

\begin{verbatim}
hemisphere <- gen_hemisphere(n = 1000)
\end{verbatim}

\begin{figure}[!]

{\centering \includegraphics[width=0.8\linewidth]{paper-cardinalR_files/figure-latex/sphere-proj-1} 

}

\caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `circle` (a1-a3), `curvycycle` (b1-b3), `unifsphere` (c1-c3), `gridedsphere` (d1-d3), `clusteredspheres` (e1-e3), and `hemisphere` (f1-f3) data.}\label{fig:sphere-proj}
\end{figure}

\paragraph{Swiss Roll}\label{swiss-roll}

To further generalize the Swiss roll structure and introduce realistic noise, we define a function \texttt{gen\_swissroll(n,\ w)}, where \(n\) is the number of points, \(p\) is the total number of dimensions, and \(w\) is the vertical range in the third dimension (Figure \ref{fig:swissroll-proj}). The first three dimensions form the classic \(3\text{-}D\) Swiss roll shape. The \[X_1 = t \cos(t), \quad X_2 = t \sin(t), \quad X_3 \sim U(w_1, w_2), \text{ where } t \sim U(0, 3\pi).\]

\begin{verbatim}
swissroll <- gen_swissroll(n = 1000, w = c(-1, 1))
\end{verbatim}

\begin{figure}[H]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/swissroll-proj-1} \caption{Three $2\text{-}D$ projections from $3\text{-}D$, for the `swissroll` data.}\label{fig:swissroll-proj}
\end{figure}

\paragraph{Trefoil knots}\label{trefoil-knots}

The Trefoil is a closed, nontrivial one-dimensional manifold embedded in \(3\text{-}D\) or \(4\text{-}D\) space (Figure \ref{fig:trefoil-proj}). The trefoil features topological complexity in the form of self-overlaps, making it a valuable test case for evaluating the ability of non-linear dimension reduction methods to preserve global structure, loops, and embeddings in high-dimensional data. Table \ref{tab:trefoil-tb-pdf} summarizes these functions.

\begin{table}

\caption{\label{tab:trefoil-tb-pdf}cardinalR trefoil data generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_trefoil4d & Trefoil in \$4\textbackslash{}text\{-\}D\$.\\
gen\_trefoil3d & Trefoil in \$3\textbackslash{}text\{-\}D\$.\\
\bottomrule
\end{tabular}
\end{table}

For the \(4\text{-}D\) trefoil knot, the function \texttt{gen\_trefoil4d(n,\ steps)} generates the structure on the \(3\)-sphere (\(S^3 \subset \mathbb{R}^4\)) using two angular parameters, \(\theta\) and \(\phi\). A band of thickness around the knot path is controlled by the \texttt{steps} argument, while the number of \(\theta\) and \(\phi\) values is determined by the \texttt{steps} and \texttt{n} arguments, respectively (Figure \ref{fig:trefoil-proj} a). The coordinates are defined as \[X_1 = \cos(\theta) \cos(\phi), \quad X_2 = \cos(\theta) \sin(\phi), \quad X_3 = \sin(\theta) \cos(1.5 \phi),\text{ and }X_4 = \sin(\theta) \sin(1.5 \phi),\] where \(\theta\) and \(\phi\) trace the knot's path.

\begin{verbatim}
trefoil4d <- gen_trefoil4d(n = 500, steps = 5)
\end{verbatim}

For the \(3\text{-}D\) stereographic projection, \texttt{gen\_trefoil3d(n,\ steps)} maps each point \((X_1, X_2, X_3, X_4) \in \mathbb{R}^4\) to \[(X_1', X_2', X_3') \in \mathbb{R}^3\text{ using }X_1' = X_1 / (1 - X_4), \quad X_2' = X_2 / (1 - X_4),\text{ and }X_3' = X_3 / (1 - X_4),\] excluding points where \(X_4 = 1\) to avoid division by zero (Figure \ref{fig:trefoil-proj} b).

\begin{verbatim}
trefoil3d <- gen_trefoil3d(n = 500, steps = 5)
\end{verbatim}

\begin{figure}[!]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/trefoil-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the `trefoil4d` (a1-a3) and `trefoil3d` (b1-b3) data.}\label{fig:trefoil-proj}
\end{figure}

\subsubsection{Generate a Spherical or Hyperspherical Hole Within a Structure}\label{generate-a-spherical-or-hyperspherical-hole-within-a-structure}

The package provides functionality for generating datasets with \textbf{spherical hole} (in 2D/3D) or, more generally, \textbf{hyperspherical hole} (in higher dimensions). These structures are valuable for evaluating how dimension reduction methods and clustering algorithms handle incomplete manifolds or missing regions of the data space. A hyperspherical hole introduces topological complexity: the structure remains continuous but contains excluded regions (voids) that algorithms must correctly represent in lower-dimensional embeddings.

The core function \texttt{gen\_hole()} removes points from a dataset that fall within a user-specified hypersphere. Formally, given data points (\(x \in \mathbb{R}^p\)), a center (\(a \in \mathbb{R}^p\)), and radius (\(r > 0\)), only points satisfying

\[
||x - a||_2 > r
\]

are retained. The anchor point (a) can either be user-specified or default to the dataset mean, and radius (r) is controlled by the user, with safeguards to avoid trivial or degenerate cases. Because it operates generically on any dataset, spherical or hyperspherical holes can be embedded in a wide range of geometric structures.

Two specialized wrappers illustrate this idea. The function \texttt{gen\_scurvehole()} generates an S-curve with a spherical hole by applying \texttt{gen\_hole()} to the output of \texttt{gen\_scurve()}. This structure has been used in prior diagnostic studies of NLDR methods \citep{wang2021}, since it tests the ability of algorithms to capture non-linear manifolds that are not simply connected. The second wrapper, \texttt{gen\_unifcubehole()}, generates uniformly sampled cube data with a hyperspherical hole. By embedding a hyperspherical void inside a convex high-dimensional structure, this creates non-convex regions that challenge algorithms in terms of separability and neighborhood preservation.

\subsubsection{Generate noise dimensions}\label{generate-noise-dimensions}

High-dimensional data structures often benefit from the addition of auxiliary noise dimensions, which can be used to assess the robustness of dimensionality reduction and clustering algorithms. The functions in this section provide flexible ways to generate random noise dimensions, ranging from purely random Gaussian variables to more structured, wavy patterns that mimic non-linear distortions in high-dimensional space. These functions can be applied independently or combined with other geometric structures to create complex simulated datasets. Table \ref{tab:noise-tb-pdf} details these functions.

\begin{table}

\caption{\label{tab:noise-tb-pdf}cardinalR noise dimensions generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_noisedims & Gaussian noise dimensions with optional mean and standard deviation.\\
gen\_wavydims1 & Wavy noise dimensions based on a user-specified theta sequence with added jitter.\\
gen\_wavydims2 & Wavy noise dimensions using polynomial transformations of an existing dimension vector.\\
gen\_wavydims3 & Wavy noise dimensions using a combination of polynomial and sine transformations based on the first three dimensions of a dataset.\\
\bottomrule
\end{tabular}
\end{table}

The \texttt{gen\_noisedims(n,\ p,\ m,\ s)} function generates \(p\) independent Gaussian noise dimensions,

\[
X_j \sim N(m_j, s_j^2), \quad j = 1, \dots, p,
\]

with odd-numbered dimensions multiplied by \(-1\) to introduce sign alternation, enhancing variability and decorrelation.

For scenarios where noise should follow a smooth wavy pattern, \texttt{gen\_wavydims1(n,\ p,\ theta)} generates dimensions as

\[
X_j = \alpha_j \theta + \varepsilon_j, \quad \varepsilon_j \sim N(0, \sigma^2), \quad j = 1, \dots, p,
\]

where each dimension is scaled by a different factor \(\alpha_j\), producing structured noise that oscillates along the latent parameter \(\theta\), mimicking trends or trajectories observed in real-world data.

The \texttt{gen\_wavydims2(n,\ p,\ x\_1)} function extends this approach by applying a non-linear transformation to an existing dimension vector \(x_1\):

\[
X_j = \beta_j \, (-1)^{\lfloor j/2 \rfloor} \, x_1^{k_j} + \varepsilon_j, \quad j = 1, \dots, p,
\]

where \(k_j\) is a randomly chosen polynomial power, \(\beta_j\) is a scaling factor, and \(\varepsilon_j\) is small uniform noise.

Finally, \texttt{gen\_wavydims3(n,\ p,\ data)} generates noise for datasets with multiple correlated dimensions. The first three dimensions are small perturbations of the original coordinates \((X_1, X_2, X_3)\), while higher dimensions are constructed via non-linear combinations, including polynomial and trigonometric transformations, e.g.,

\[
X_j = f_j(X_1, X_2, X_3) + \varepsilon_j, \quad j > 3,
\]

producing high-dimensional noise that preserves some geometric correlation with the base structure while introducing additional complexity.

\subsubsection{Multiple cluster examples}\label{multiple-cluster-examples}

By using the shape generators mentioned above, we can create various examples of multiple clusters. The package includes some of these examples, which are described in Table \ref{tab:odd-shape-tb-pdf}.

\begin{table}

\caption{\label{tab:odd-shape-tb-pdf}cardinalR multiple clusters generation functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{3.5cm}>{\raggedright\arraybackslash}p{8.5cm}}
\toprule
Function & Explanation\\
\midrule
make\_mobiusgau & Möbius-like cluster combined with a Gaussian.\\
make\_multigau & Multiple Gaussian clusters in high-dimensional space.\\
make\_curvygau & Curvilinear cluster with a Gaussian cluster.\\
make\_klink\_circles & K-link circular clusters (non-linear circular patterns).\\
make\_chain\_circles & Chain-like circular clusters connected sequentially.\\
\addlinespace
make\_klink\_curvycycle & K-link curvy cycle clusters (curvilinear loop structures).\\
make\_chain\_curvycycle & Chain-like curvy cycle clusters connected sequentially.\\
make\_gaucircles & Circular clusters with a Gaussian cluster in the middle.\\
make\_gaucurvycycle & Curvy circular clusters with a Gaussian cluster in the middle.\\
make\_onegrid & Single grid in two dimensions.\\
\addlinespace
make\_twogrid\_overlap & Two overlapping grids.\\
make\_twogrid\_shift & Two grids shifted relative to each other.\\
make\_shape\_para & Parallel shaped clusters.\\
make\_three\_clust\_ & Three clusters with different shapes. (eg:- 01, 02, ..., 20)\\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Additional functions}\label{additional-functions}

The package includes various supplementary tools in addition to the shape generating functions mentioned earlier. These tools allow users to create background noise, randomize the rows of the data, relocate clusters, generate a vector whose product and sum are approximately equal to a target value, rotate structures, and normalize the data. Table \ref{tab:add-tb-pdf} details these functions.

\begin{table}

\caption{\label{tab:add-tb-pdf}cardinalR additional functions}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{4cm}>{\raggedright\arraybackslash}p{8cm}}
\toprule
Function & Explanation\\
\midrule
gen\_bkgnoise & Adds background noise.\\
randomize\_rows & Randomizes the rows.\\
relocate\_clusters & Relocates the clusters.\\
gen\_nproduct & Generates a vector of positive integers whose product is approximately equal to a target value.\\
gen\_nsum & Generates a vector of positive integers whose summation is approximately equal to a target value.\\
\addlinespace
gen\_rotation & Generates rotations.\\
normalize\_data & Normalizes data.\\
\bottomrule
\end{tabular}
\end{table}

\section{Application}\label{application}

This section illustrates the use of package by generating a synthetic dataset to evaluate the performance of six popular dimension reduction techniques: Principal Component Analysis (PCA) \citep{jolliffe2011}, t-distributed stochastic neighbor embedding (tSNE) \citep{laurens2008}, uniform manifold approximation and projection (UMAP) \citep{leland2018}, potential of heat-diffusion for affinity-based trajectory embedding (PHATE) algorithm \citep{moon2019}, large-scale dimensionality reduction Using triplets (TriMAP) \citep{amid2019}, and pairwise controlled manifold approximation (PaCMAP) \citep{yingfan2021}.

The following code generates a dataset of five clusters, positioned with equal inter-cluster distances in \(4\text{-}D\) space (Figure \ref{fig:highd-proj}). Each cluster was chosen to reflect distinct geometric and topological properties, allowing us to test how well DR methods preserve both local and global structures. The \emph{helical spiral} cluster is designed to evaluate methods on elongated, twisting structures that challenge linear embeddings such as PCA and require preservation of curvilinear continuity. The \emph{hemisphere} provides a curved surface with partial coverage of a \(3\text{-}D\) manifold, useful for testing neighborhood preservation and unfolding in algorithms like UMAP and tSNE. The \emph{uniform cube} represents isotropic, uniformly distributed data and serves as a control cluster with simple geometric structure to assess baseline embedding fidelity. The \emph{cone} introduces variable density along one axis, mimicking structures where point density changes with geometry, helping evaluate how well algorithms maintain relative distances in non-uniform distributions. Finally, the \emph{Gaussian} cluster is a standard multivariate normal distribution, included to assess algorithm performance on simple, spherical, high-density clusters. Together, these clusters create a challenging synthetic dataset suitable for benchmarking and exploring the strengths and weaknesses of different dimensionality reduction techniques.

\begin{verbatim}
positions <- geozoo::simplex(p=4)$points
positions <- positions * 0.8

## To generate data
five_clusts <- gen_multicluster(n = c(2250, 1500, 750, 1250, 1750), k = 5,
                       loc = positions,
                       scale = c(0.4, 0.35, 0.3, 1, 0.3),
                       shape = c("helicalspiral", "hemisphere", "unifcube", 
                                 "cone", "gaussian"),
                       rotation = NULL,
                       is_bkg = FALSE)
\end{verbatim}

The five clusters have different geometric structures and each contain different number of points. Specifically, the helical spiral cluster includes \(2250\) points and was generated with a scale parameter of \(0.4\). The hemisphere cluster consists of \(1500\) points with a scale parameter of \(0.35\). The uniform cube-shaped cluster contains \(750\) points and uses a scale parameter of \(0.3\). The blunted cone cluster includes \(1250\) points, generated with a scale parameter of \(1\). Finally, the Gaussian-shaped cluster contains \(1750\) points and was generated with a scale parameter of \(0.3\).

\begin{figure}[H]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/highd-proj-1} \caption{Three $2\text{-}D$ projections from $4\text{-}D$, for the five clusters data. The helical spiral cluster is represented in dark green, the hemisphere cluster in orange, the uniform cube-shaped cluster in purple, the blunted cone cluster in pink, and the Gaussian-shaped cluster in light green.}\label{fig:highd-proj}
\end{figure}

UMAP, PHATE, TriMAP, and PaCMAP effectively separate the five clusters and show the preservation of the global structure (Figure \ref{fig:fig-nldr-layouts}). However, PHATE reveals three non-linear clusters, even though two of them do not show non-linearity. UMAP, TriMAP, and PaCMAP successfully maintain the local structures of the data. In contrast, tSNE divides the non-linear cluster into sub-clusters. Also, tSNE fails to preserve the distances between the clusters. PCA, on the other hand, preserves the local structures of the clusters, but some clusters are incorrectly merged that should remain distinct.

\begin{figure}[H]
\includegraphics[width=1\linewidth]{paper-cardinalR_files/figure-latex/fig-nldr-layouts-1} \caption{Six different dimension reduction representations of the five clusters data using default hyperparameter settings: (a) tSNE, (b) UMAP, (c) PAHTE, (d) TriMAP, (e) PaCMAP, and (f) PCA.}\label{fig:fig-nldr-layouts}
\end{figure}

\section{Conclusion}\label{conclusion}

The \texttt{cardinalR} package introduces a flexible framework for generating high-dimensional data structures with well-defined geometric properties. It addresses an important need in the evaluation of clustering, machine learning, and DR methods by enabling the construction of customized datasets with interpretable structures, noise characteristics, and clustering arrangements. In this way, \texttt{cardinalR} complements existing packages such as \texttt{geozoo}, \texttt{snedata}, and \texttt{mlbench}, while extending the scope to higher dimensions and more complex shapes.

The motivation for developing this package originated from the need to design a perception--misperception experiment, aimed at investigating how well NLDR methods preserve inter-cluster structure. To conduct this study, we required simulated datasets with carefully controlled geometric and clustering properties. While some existing packages provided useful starting points, none fully supported the creation of flexible, high-dimensional data with the specific structural variations needed for our experiment. Developing these generators for research purposes gradually led to the design of \texttt{cardinalR} as a general-purpose package, so that other researchers can benefit from the same tools for simulation, benchmarking, and teaching.

The included structures cover a wide range of diagnostic settings. Branching shapes facilitate the study of continuity and topological preservation, the Scurve with a hole allows investigation of incomplete manifolds, and clustered spheres assess separability on curved surfaces. The Möbius strip introduces challenges from non-orientable geometry, while gridded cubes and pyrholes test spatial regularity and clustering in sparse, non-convex regions.

These structures are designed to support not only algorithm diagnostics, but also teaching high-dimensional concepts, benchmarking reproducibility, and evaluating hyperparameter sensitivity. By allowing users to adjust dimensionality, sample size, noise, and clustering properties, the package promotes transparent experimentation and comparative model evaluation.

Future extensions of \texttt{cardinalR} may include biologically inspired or application-driven data structures would further broaden its utility in domains such as bioinformatics, forensic science, and spatial analysis.

\section{Acknowledgements}\label{acknowledgements}

The source material for this paper is available at \href{https://github.com/JayaniLakshika/paper-cardinalR}{github.com/JayaniLakshika/paper-cardinalR}.

This article is created using \CRANpkg{knitr} \citep{yihui2015} and \CRANpkg{rmarkdown} \citep{yihui2018} in R with the \texttt{rjtools::rjournal\_article} template. These \texttt{R} packages were used for this work: \texttt{cli} \citep{gabor2025}, \texttt{tibble} \citep{kirill2023}, \texttt{gtools} \citep{gregory2023}, \texttt{dplyr} \citep{hadley2023}, \texttt{stats} \citep{core2025}, \texttt{tidyr} \citep{hadley2024}, \texttt{purrr} \citep{hadley2025}, \texttt{mvtnorm} \citep{alan2009}, \texttt{geozoo} \citep{barret2016}, and \texttt{MASS} \citep{venables2002}.

\bibliography{paper-cardinalR.bib}

\address{%
Jayani P. Gamage\\
Monash University\\%
Department of Econometrics and Business Statistics, VIC 3800 Australia\\
%
\url{https://jayanilakshika.netlify.app/}\\%
\textit{ORCiD: \href{https://orcid.org/0000-0002-6265-6481}{0000-0002-6265-6481}}\\%
\email{jayani.piyadigamage@monash.edu}%
}

\address{%
Dianne Cook\\
Monash University\\%
Department of Econometrics and Business Statistics, VIC 3800 Australia\\
%
\url{http://www.dicook.org/}\\%
\textit{ORCiD: \href{https://orcid.org/0000-0002-3813-7155}{0000-0002-3813-7155}}\\%
\href{mailto:dicook@monash.edu}{\nolinkurl{dicook@monash.edu}}%
}

\address{%
Paul Harrison\\
Monash University\\%
MGBP, BDInstitute, VIC 3800 Australia\\
%
%
\textit{ORCiD: \href{https://orcid.org/0000-0002-3980-268X}{0000-0002-3980-268X}}\\%
\href{mailto:paul.harrison@monash.edu}{\nolinkurl{paul.harrison@monash.edu}}%
}

\address{%
Michael Lydeamore\\
Monash University\\%
Department of Econometrics and Business Statistics, VIC 3800 Australia\\
%
%
\textit{ORCiD: \href{https://orcid.org/0000-0001-6515-827X}{0000-0001-6515-827X}}\\%
\href{mailto:michael.lydeamore@monash.edu}{\nolinkurl{michael.lydeamore@monash.edu}}%
}

\address{%
Thiyanga S. Talagala\\
University of Sri Jayewardenepura\\%
Department of Statistics, Gangodawila, Nugegoda 10100 Sri Lanka\\
%
\url{https://thiyanga.netlify.app/}\\%
\textit{ORCiD: \href{https://orcid.org/0000-0002-0656-9789}{0000-0002-0656-9789}}\\%
\href{mailto:ttalagala@sjp.ac.lk}{\nolinkurl{ttalagala@sjp.ac.lk}}%
}
